{"version":3,"sources":["./src/app/services/compilador.service.ts","fs (ignored)","path (ignored)","./src/Backend/build/Xpath/ControlError.js","stream (ignored)","./src/Backend/build/Reportes/NodoReporteGramatica.js","./src/Backend/src_backend/index.ts","./src/Backend/build/Xml/XmlResultado.js","./src/Backend/build/Xpath/NodoControlError.js","./src/environments/environment.ts","./src/app/components/arbol-ast/arbol-ast.component.ts","./src/app/components/arbol-ast/arbol-ast.component.html","./src/app/components/tabla-errores/tabla-errores.component.ts","./src/app/components/tabla-errores/tabla-errores.component.html","./src/Backend/build/Xml/EtiquetaDoble.js","./src/Backend/build/Xpath/OpBinaria.js","./src/Backend/build/Xml/Atributo.js","./src/Backend/build/Xml/Tabla.js","./src/Backend/build/Grammar/xmlD.js","./src/Backend/build/Xpath/Primitivo.js","./src/Backend/build/Grammar/xmlA.js","./src/Backend/build/Xpath/TipoSeleccion.js","./src/Backend/build/Xml/Tipos.js","./src/Backend/build/Grammar/xpathA.js","./src/app/app.component.ts","./src/app/app.component.html","./src/Backend/build/Xml/EtiquetaSimple.js","./src/app/components/editor/editor.component.ts","./src/app/components/editor/editor.component.html","./src/Backend/build/Xpath/TiposOp.js","./src/Backend/build/Grammar/xpathD.js","./src/app/app.module.ts","./src/Backend/build/Xpath/TipoVal.js","./src/app/components/tabla-simbolos/tabla-simbolos.component.html","./src/app/components/tabla-simbolos/tabla-simbolos.component.ts","./src/Backend/build/Xml/Fila.js","./src/Backend/build/Reportes/ReporteGramatica.js","./src/Backend/build/Graficas/Graficas.js","./src/Backend/build/Xml/EtiquetaInicio.js","./src/app/app-routing.module.ts","./src/main.ts","./$_lazy_route_resource lazy namespace object"],"names":[],"mappings":"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Cb,sEAAI;QAAA,iEAAK;QAAA,4DAAK;QACd,sEAAI;QAAA,gEAAI;QAAA,4DAAK;QACb,sEAAI;QAAA,mEAAO;QAAA,4DAAK;QACpB,4DAAK;QACT,4DAAQ;QACR,yEAAO;QACH,sEAAI;QACA,sEAAI;QAAA,6DAAC;QAAA,4DAAK;QACV,sEAAI;QAAA,6DAAC;QAAA,4DAAK;QACV,sEAAI;QAAA,6DAAC;QAAA,4DAAK;QACV,sEAAI;QAAA,6DAAC;QAAA,4DAAK;QACd,4DAAK;QACT,4DAAQ;QACZ,4DAAQ;QACZ,4DAAM;QACN,iEAAI;QACR,4DAAM;QACV,4DAAM;QACV,4DAAM;QACV,4DAAM;;;;;;;;;;;;;;AClCO;AACb,8CAA8C,cAAc;AAC5D,mBAAmB,mBAAO,CAAC,kCAAsB;AACjD,eAAe,mBAAO,CAAC,oBAAQ;AAC/B,gBAAgB,mBAAO,CAAC,qBAAS;AACjC,gBAAgB,mBAAO,CAAC,qBAAS;AACjC,uBAAuB,mBAAO,CAAC,mCAAuB;AACtD,wBAAwB,mBAAO,CAAC,oCAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,WAAW,aAAa,aAAa;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,eAAe,aAAa,iBAAiB,kBAAkB,gBAAgB;AAC5H;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1Ma;AACb,8CAA8C,cAAc;AAC5D,oBAAoB,mBAAO,CAAC,yBAAa;AACzC,kBAAkB,mBAAO,CAAC,uBAAW;AACrC,kBAAkB,mBAAO,CAAC,uBAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpGa;AACb,8CAA8C,cAAc;AAC5D,mBAAmB,mBAAO,CAAC,kCAAsB;AACjD,eAAe,mBAAO,CAAC,oBAAQ;AAC/B,gBAAgB,mBAAO,CAAC,qBAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,kBAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1Ca;AACb,8CAA8C,cAAc;AAC5D,wBAAwB,mBAAO,CAAC,oCAAwB;AACxD,kBAAkB,mBAAO,CAAC,8BAAkB;AAC5C;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3FA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,eAAe,kCAAkC;AACjD,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mJAAmJ;AACnJ,SAAS;;AAET;AACA;AACA,qBAAqB,+BAA+B;AACpD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB,eAAe,KAAK;AACxE,SAAS,UAAU,EAAE;AACrB,kBAAkB,0BAA0B,EAAE;AAC9C,cAAc;AACd,mBAAmB,2jBAA2jB;AAC9kB,qBAAqB,sQAAsQ;AAC3R;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,mEAAmE,GAAG,SAAS,GAAG,4CAA4C,GAAG,aAAa,GAAG,0BAA0B,eAAe,6CAA6C,IAAI,kFAAkF,mBAAmB,cAAc,GAAG,oEAAoE,GAAG,aAAa,GAAG,YAAY,GAAG,cAAc,eAAe,0BAA0B,IAAI,cAAc,+BAA+B,6CAA6C,oBAAoB,kBAAkB,GAAG,kBAAkB,oBAAoB,cAAc,qDAAqD,2BAA2B,qCAAqC,YAAY,iDAAiD,0BAA0B,IAAI,cAAc;AACx6B,yBAAyB,yBAAyB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE,oCAAoC;AACpC;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,WAAW,gBAAgB,GAAG,mBAAO,CAAC,kCAAsB;AAC5D,WAAW,iBAAiB,GAAG,mBAAO,CAAC,mCAAuB;AAC9D,WAAW,iBAAiB,GAAG,mBAAO,CAAC,mCAAuB;AAC9D,WAAW,WAAW,GAAG,mBAAO,CAAC,6BAAiB;AAClD,WAAW,eAAe,GAAG,mBAAO,CAAC,iCAAqB;AAC1D,WAAW,eAAe,GAAG,mBAAO,CAAC,mCAAuB;AAC5D,WAAW,mBAAmB,GAAG,mBAAO,CAAC,0CAA8B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yBAAyB,eAAe,oCAAoC,kBAAkB,wEAAwE,iBAAiB,4CAA4C,cAAc,6DAA6D;AAC9S,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,IAAI,IAAgE;AACpE;AACA;AACA,iCAAiC,0CAA0C;AAC3E;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,WAAI,eAAe,mBAAO,CAAC,aAAM;AAC9D;AACA;AACA,QAAQ,KAA6B,IAAI,4CAAY;AACrD;AACA;AACA;;;;;;;;;;;;;;ACr1Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACXA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,eAAe,kCAAkC;AACjD,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mJAAmJ;AACnJ,SAAS;;AAET;AACA;AACA,qBAAqB,+BAA+B;AACpD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB,eAAe,KAAK;AACxE,SAAS,UAAU,EAAE;AACrB,kBAAkB,0BAA0B,EAAE;AAC9C,cAAc;AACd,mBAAmB,qdAAqd;AACxe,qBAAqB,sQAAsQ;AAC3R;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,mEAAmE,GAAG,SAAS,GAAG,4CAA4C,GAAG,kDAAkD,GAAG,0BAA0B,mBAAmB,yEAAyE,mBAAmB,cAAc,GAAG,oDAAoD,GAAG,kDAAkD,GAAG,YAAY,mBAAmB,+BAA+B,oBAAoB,cAAc,GAAG,sDAAsD,GAAG,iBAAiB,mBAAmB,cAAc,mBAAmB,4CAA4C,qCAAqC,YAAY,qCAAqC,cAAc;AAC9zB,yBAAyB,yBAAyB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE,oCAAoC;AACpC;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,WAAW,gBAAgB,GAAG,mBAAO,CAAC,kCAAsB;AAC5D,WAAW,iBAAiB,GAAG,mBAAO,CAAC,mCAAuB;AAC9D,WAAW,iBAAiB,GAAG,mBAAO,CAAC,mCAAuB;AAC9D,WAAW,WAAW,GAAG,mBAAO,CAAC,6BAAiB;AAClD,WAAW,eAAe,GAAG,mBAAO,CAAC,iCAAqB;AAC1D,WAAW,eAAe,GAAG,mBAAO,CAAC,mCAAuB;AAC5D,WAAW,gBAAgB,GAAG,mBAAO,CAAC,oCAAwB;AAC9D,WAAW,mBAAmB,GAAG,mBAAO,CAAC,0CAA8B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yBAAyB,eAAe,oCAAoC,kBAAkB,wEAAwE,iBAAiB,4CAA4C,cAAc,6DAA6D;AAC9S,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,IAAI,IAAgE;AACpE;AACA;AACA,iCAAiC,0CAA0C;AAC3E;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,WAAI,eAAe,mBAAO,CAAC,aAAM;AAC9D;AACA;AACA,QAAQ,KAA6B,IAAI,4CAAY;AACrD;AACA;AACA;;;;;;;;;;;;;;AC9yBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE;;;;;;;;;;;;;ACT1D;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;;;;;;;;;;;;ACT/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,eAAe,kCAAkC;AACjD,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mJAAmJ;AACnJ,SAAS;;AAET;AACA;AACA,qBAAqB,+BAA+B;AACpD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB,eAAe,KAAK;AACxE,SAAS,UAAU,EAAE;AACrB,kBAAkB,0BAA0B,EAAE;AAC9C,cAAc;AACd,mBAAmB,8XAA8X;AACjZ,qBAAqB,oPAAoP;AACzQ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,kEAAkE,GAAG,SAAS,GAAG,yBAAyB,kBAAkB,iDAAiD,oCAAoC,kEAAkE,GAAG,0BAA0B,mCAAmC,YAAY,GAAG,uDAAuD,kCAAkC,sBAAsB,IAAI,2BAA2B,sFAAsF,iDAAiD,qBAAqB,2BAA2B,qCAAqC,0DAA0D,sDAAsD,2BAA2B,GAAG,2BAA2B,GAAG,2BAA2B,GAAG,2BAA2B,mBAAmB,mBAAmB,oBAAoB,mBAAmB;AAC/gC,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE,oCAAoC;AACpC;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,WAAW,gBAAgB,GAAG,mBAAO,CAAC,oCAAwB;AAC9D,WAAW,YAAY,GAAG,mBAAO,CAAC,gCAAoB;AACtD,WAAW,UAAU,GAAG,mBAAO,CAAC,8BAAkB;AAClD,WAAW,YAAY,GAAG,mBAAO,CAAC,gCAAoB;AACtD,WAAW,UAAU,GAAG,mBAAO,CAAC,8BAAkB;AAClD,WAAW,eAAe,GAAG,mBAAO,CAAC,mCAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yBAAyB,aAAa,qNAAqN;AAC3P,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,IAAI,IAAgE;AACpE;AACA;AACA,iCAAiC,8CAA8C;AAC/E;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,WAAI,eAAe,mBAAO,CAAC,aAAM;AAC9D;AACA;AACA,QAAQ,KAA6B,IAAI,4CAAY;AACrD;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACx0BO,MAAM,YAAY;IALzB;QAME,UAAK,GAAG,UAAU,CAAC;KACpB;;wEAFY,YAAY;4FAAZ,YAAY;QCPzB,2EAA+B;;;;;;;;;;;;;;ACAlB;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,oBAAQ;AAC/B,gBAAgB,mBAAO,CAAC,qBAAS;AACjC,gBAAgB,mBAAO,CAAC,qBAAS;AACjC,mBAAmB,mBAAO,CAAC,kCAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,eAAe,aAAa,iBAAiB,kBAAkB,gBAAgB;AAC5H;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmC;AAER;AAGM;AACjC,2BAA2B;AACmB;AAMP;;;;;;;;;IC+BX,0EAA4I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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;;;;;;;;;;;;ACjBrD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,eAAe,kCAAkC;AACjD,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mJAAmJ;AACnJ,SAAS;;AAET;AACA;AACA,qBAAqB,+BAA+B;AACpD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB,eAAe,KAAK;AACxE,SAAS,UAAU,EAAE;AACrB,kBAAkB,0BAA0B,EAAE;AAC9C,cAAc;AACd,mBAAmB,igBAAigB;AACphB,qBAAqB,oPAAoP;AACzQ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,mEAAmE,GAAG,SAAS,GAAG,aAAa,GAAG,wBAAwB,kBAAkB,wDAAwD,qCAAqC,kFAAkF,mCAAmC,YAAY,GAAG,YAAY,GAAG,wDAAwD,oDAAoD,8BAA8B,IAAI,mCAAmC,uEAAuE,wBAAwB,qCAAqC,mCAAmC,sDAAsD,YAAY,GAAG,cAAc,GAAG,cAAc,GAAG,cAAc;AAC11B,yBAAyB,+DAA+D;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE,oCAAoC;AACpC;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,WAAW,gBAAgB,GAAG,mBAAO,CAAC,oCAAwB;AAC9D,WAAW,YAAY,GAAG,mBAAO,CAAC,gCAAoB;AACtD,WAAW,UAAU,GAAG,mBAAO,CAAC,8BAAkB;AAClD,WAAW,YAAY,GAAG,mBAAO,CAAC,gCAAoB;AACtD,WAAW,UAAU,GAAG,mBAAO,CAAC,8BAAkB;AAClD,WAAW,eAAe,GAAG,mBAAO,CAAC,mCAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yBAAyB,aAAa,qNAAqN;AAC3P,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,IAAI,IAAgE;AACpE;AACA;AACA,iCAAiC,8CAA8C;AAC/E;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,WAAI,eAAe,mBAAO,CAAC,aAAM;AAC9D;AACA;AACA,QAAQ,KAA6B,IAAI,4CAAY;AACrD;AACA;AACA;;;;;;;;;;;;;;ACz2BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0D;AAEQ;AACV;AAEA;AACT;AACwB;AACS;AACD;AACM;AACQ;;AA0BtF,MAAM,SAAS;;kEAAT,SAAS;yFAAT,SAAS,cAFR,2DAAY;8FANb;QACT;YACE,OAAO,EAAE,yEAAW;YACpB,QAAQ,EAAE,+CAA+C;SAC1D;KACF,YAdQ;YACP,uEAAa;YACb,oEAAgB;YAChB,kEAAmB;YACnB,0DAAW;YACX,gFAAkB;YAClB,4FAAuB;YACvB,qEAAgB;SACjB;oIASU,SAAS,mBAtBlB,2DAAY;QACZ,mFAAe;QACf,kGAAiB;QACjB,0GAAsB,aAGtB,uEAAa;QACb,oEAAgB;QAChB,kEAAmB;QACnB,0DAAW;QACX,gFAAkB;QAClB,4FAAuB;QACvB,qEAAgB;;;;;;;;;;;;;AC3BP;AACb,8CAA8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","file":"main.js","sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpClient, HttpHeaders } from \"@angular/common/http\";\nimport { Observable } from \"rxjs\";\nimport { Analisis_D, Analizar_XML } from './../../Backend/src_backend/index'\nimport { ReporteGramatica } from 'src/Backend/src_backend/Reportes/ReporteGramatica';\n//import { Analizar_XML } from '../Backend/src_backend/index';\n@Injectable({\n  providedIn: 'root'\n})\nexport class CompiladorService {\n  constructor(private http: HttpClient) { }\n\n  analizar(codigo: string , texto_xpath:string) {\n    \n\n\n\n    Analizar_XML(codigo,texto_xpath)\n    var alv = {\n      simbolo: Analizar_XML(codigo,texto_xpath).simbolo,\n      cst:Analizar_XML(codigo,texto_xpath).cst,\n      consulta:Analizar_XML(codigo,texto_xpath).consulta,\n      ReporteGramatica:Analizar_XML(codigo,texto_xpath).ReporteGramatica,\n      Error:Analizar_XML(codigo,texto_xpath).Error,\n      Encoding:Analizar_XML(codigo,texto_xpath).Encoding\n      \n      \n    }\n    return alv\n  }\n\n\n  analizarD(codigo: string , texto_xpath:string) {\n\n\n\n\n    Analisis_D(codigo,texto_xpath)\n    var alv = {\n      simbolo: Analisis_D(codigo,texto_xpath).simbolo,\n      cst:Analisis_D(codigo,texto_xpath).cst,\n      consulta:Analisis_D(codigo,texto_xpath).consulta,\n      ReporteGramatica:Analisis_D(codigo,texto_xpath).ReporteGramatica,\n      Error:Analisis_D(codigo,texto_xpath).Error,\n      Encoding:Analisis_D(codigo,texto_xpath).Encoding\n      \n      \n    }\n    return alv\n  }\n\n  getAstBase64(ast: any): Observable<any> {\n    const json = { ast: ast }\n    return this.http.post<any>('http://localhost:3000/getAstBase64', json);\n  }\n\n}\n","/* (ignored) */","/* (ignored) */","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst TipoSeleccion_1 = require(\"./TipoSeleccion\");\r\nconst NodoControlError_1 = require(\"./NodoControlError\");\r\nclass ControlError {\r\n    constructor(simbolo, tipo, linea, columna, entorno) {\r\n        console.log(\"adentro\");\r\n        ControlError.ListaE.push(new NodoControlError_1.NodoControlError(simbolo, tipo, linea, columna, entorno));\r\n        console.log(ControlError.ListaE);\r\n    }\r\n    static Agregar(simbolo, tipo, linea, columna, entorno) {\r\n        ControlError.ListaE.push(new NodoControlError_1.NodoControlError(simbolo, tipo, linea, columna, entorno));\r\n    }\r\n}\r\nexports.ControlError = ControlError;\r\nControlError.ListaE = [];\r\nfunction graficar(errores, errorbusqueda = {\r\n    simbolo: \"\",\r\n    tipo: \"\",\r\n    linea: \"\",\r\n    columna: \"\",\r\n}) {\r\n    var text = \"\";\r\n    for (let set of errores) {\r\n        if (set.tipo === TipoSeleccion_1.TipoSeleccion.ERROR_LEXICO) {\r\n            text = text + '\\n' + \"simbolo de error: \" + set.simbolo + \" tipo: error lexico\" + \" \" + set.linea + \" \" + set.columna;\r\n        }\r\n        else if (set.tipo === TipoSeleccion_1.TipoSeleccion.ERROR_SINTACTICO) {\r\n            text = text + '\\n' + \"simbolo de error: \" + set.simbolo + \" tipo: error sintactico\" + \" \" + set.linea + \" \" + set.columna;\r\n        }\r\n    }\r\n    return text;\r\n}\r\nexports.graficar = graficar;\r\n","/* (ignored) */","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass NodoReporteGramatica {\r\n    constructor(produccion, regla_semantica) {\r\n        this.produccion = produccion;\r\n        this.regla_semantica = regla_semantica;\r\n    }\r\n}\r\nexports.NodoReporteGramatica = NodoReporteGramatica;\r\n","\nimport { Fila } from './Xml/Fila';\nimport { XmlResultado } from './Xml/XmlResultado';\n//import { SimbolsReport } from './Reportes/TablaSimbolos'\nimport Parser from '../build/Grammar/xmlA.js'\n\nimport parserXpath from '../build/Grammar/xpathA.js'\n\nimport ParserD from '../build/Grammar/xmlD.js'\n\nimport parserXpathD from '../build/Grammar/xpathD.js'\nimport { ReporteGramatica } from '../build/Reportes/ReporteGramatica.js';\nimport { ControlError } from '../build/Xpath/ControlError.js';\nimport { Observable } from 'rxjs';\n\n\n\n\n\nconst port = 3000;\n//const parserXpath = require('./Grammar/xpathA.js');\n\n\n\n\n\n\nexport function Analizar_XML(entrada: string,texto_path:string) {\n\n  // aqui voy a vaciar antes que nada los nuevos simbolos\n  //imbolsReport.aux = \"\";\n\n\n  /**\n   * \n   * const tree:XmlResultado = parser.parse(entrada)\n  const {XmlResultado,errores} = parser.parse(entrada);\n  //const {resXpath, errores} = parserXpath.parse(\"#//videojuego\")\n  const {resXpathD, erroresD}  = parserxpathD.parse(\"#//videojuego@\")\n  console.log(\"Respuesta xpathD:\")\n  console.log(JSON.stringify(resXpathD, null, 2))\n  console.log(\"\\nResultado de busqueda:\")\n  console.log(tree.getAsTable().buscar(resXpathD))\n // console.log(graficar(errores))\n  console.log(graficar(erroresD))\n   * \n   * \n   * */ \n  //console.log(\"suu adentro papasito\")\n \n let Rxpath=\"\";\n \n    \n\n  const tree: XmlResultado =Parser.parse(entrada)\n  \n const resXpath:any = parserXpath.parse(texto_path)\n  // Rxpath+=\"Respuesta xpath:\"\n   Rxpath+=resXpath\n  //console.log(\"\\nResultado de busqueda:\")\n  Rxpath+=tree.getAsTable().buscar(resXpath);\n\n\n\n\n\n\n  /*  aqui termina el llenado de la tabla de simbolos **/\n\n\n\n\n\n  console.log(tree.getErroresSemanticos())\n  // console.log(Xpath)\n  //console.log(tree.getCstDotA());\n /// console.log(ControlError.ListaE)\n  //console.log(\"alv\"+ReporteGramatica.Lista)\n  var alv ={\n\n    ReporteGramatica:ReporteGramatica.Lista,\n   cst:tree.getCstDotA(),\n   simbolo: tree.getAsTable().filas,\n   consulta:Rxpath,\n   Error:ControlError.ListaE,\n   Encoding:tree.etiquitaInicio.encoding\n   \n\n  }\n\n  ControlError.ListaE = []\n  ReporteGramatica.Lista=[]\n\n  return alv\n\n}\n\n\n\nexport function Analisis_D(entrada: string,texto_path:string) {\n\n  // aqui voy a vaciar antes que nada los nuevos simbolos\n  //imbolsReport.aux = \"\";\n\n\n  /**\n   * \n   * const tree:XmlResultado = parser.parse(entrada)\n  const {XmlResultado,errores} = parser.parse(entrada);\n  //const {resXpath, errores} = parserXpath.parse(\"#//videojuego\")\n  const {resXpathD, erroresD}  = parserxpathD.parse(\"#//videojuego@\")\n  console.log(\"Respuesta xpathD:\")\n  console.log(JSON.stringify(resXpathD, null, 2))\n  console.log(\"\\nResultado de busqueda:\")\n  console.log(tree.getAsTable().buscar(resXpathD))\n // console.log(graficar(errores))\n  console.log(graficar(erroresD))\n   * \n   * \n   * */ \n  //console.log(\"suu adentro papasito\")\n \n let Rxpath=\"\";\n \n\n\n  const tree: XmlResultado =ParserD.parse(entrada)\n\n\n  const alv2=ParserD.parse(entrada)\n const resXpath:any = parserXpathD.parse(texto_path)\n   Rxpath+=\"Respuesta xpath:\"\n   Rxpath+=resXpath\n  //console.log(\"\\nResultado de busqueda:\")\n  Rxpath+=tree.getAsTable().buscar(resXpath);\n\n\n\n\n\n\n  /*  aqui termina el llenado de la tabla de simbolos **/\n\n\n\n\n\n  console.log(tree.getErroresSemanticos())\n  // console.log(Xpath)\n  //console.log(tree.getCstDotA());\n // console.log(ControlError.ListaE)\n  //console.log(\"alv\"+ReporteGramatica.Lista)\n  var alv ={\n\n    ReporteGramatica:ReporteGramatica.Lista,\n   cst:tree.getCstDotD(),\n   simbolo: tree.getAsTable().filas,\n   consulta:Rxpath,\n   Error:ControlError.ListaE,\n   Encoding:tree.etiquitaInicio.encoding\n   \n\n  }\n\n  ControlError.ListaE = []\n  ReporteGramatica.Lista=[]\n\n  return alv\n\n}\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Graficas_1 = require(\"../Graficas/Graficas\");\r\nconst Tabla_1 = require(\"./Tabla\");\r\nclass XmlResultado {\r\n    constructor(etiquitaInicio, etiquetasCuerpo) {\r\n        this.etiquitaInicio = etiquitaInicio;\r\n        this.etiquetasCuerpo = etiquetasCuerpo;\r\n    }\r\n    imprimir() {\r\n        let texto = \"\";\r\n        this.etiquetasCuerpo.forEach(etiqueta => {\r\n            texto += etiqueta.imprimir();\r\n        });\r\n        return texto;\r\n    }\r\n    getAsTable() {\r\n        let tabla = new Tabla_1.Tabla();\r\n        this.etiquetasCuerpo.forEach(etiqueta => {\r\n            etiqueta.getAsTable().filas.forEach(fila => {\r\n                tabla.addFila(fila);\r\n            });\r\n        });\r\n        return tabla;\r\n    }\r\n    getErroresSemanticos() {\r\n        let texto = \"\";\r\n        this.etiquetasCuerpo.forEach(etiqueta => {\r\n            texto += etiqueta.getErroresSemanticos();\r\n        });\r\n        return texto;\r\n    }\r\n    getCstDotA() {\r\n        let texto = \"\";\r\n        texto += \"digraph {\\n\";\r\n        texto += Graficas_1.Graficas.defNodo(0, \"XML\");\r\n        texto += Graficas_1.Graficas.getElement(1, \"TAG_CONFIGURACION\", 0);\r\n        texto += this.etiquitaInicio.getCstDotA(1);\r\n        if (this.etiquetasCuerpo.length > 0) {\r\n            let cont = 3;\r\n            for (let etiqueta of this.etiquetasCuerpo) {\r\n                if (cont - 3 != this.etiquetasCuerpo.length - 1) {\r\n                    texto += Graficas_1.Graficas.getElement(cont, \"LISTA_ETIQUETAS\", cont + 1);\r\n                    texto += etiqueta.getCstDotA(cont);\r\n                }\r\n                else {\r\n                    texto += Graficas_1.Graficas.getElement(cont, \"LISTA_ETIQUETAS\", 0);\r\n                    texto += etiqueta.getCstDotA(cont);\r\n                }\r\n                cont += 1;\r\n            }\r\n        }\r\n        texto += \"}\";\r\n        return texto;\r\n    }\r\n    getCstDotD() {\r\n        let texto = \"\";\r\n        texto += \"digraph {\\n\";\r\n        texto += Graficas_1.Graficas.defNodo(0, \"XML\");\r\n        texto += Graficas_1.Graficas.getElement(1, \"TAG_CONFIGURACION\", 0);\r\n        texto += this.etiquitaInicio.getCstDotA(1);\r\n        if (this.etiquetasCuerpo.length > 0) {\r\n            let cont = 3;\r\n            for (let etiqueta of this.etiquetasCuerpo) {\r\n                if (cont === 3) {\r\n                    texto += Graficas_1.Graficas.getElement(cont, \"LISTA_ETIQUETAS\", 0);\r\n                    texto += etiqueta.getCstDotD(cont);\r\n                }\r\n                else {\r\n                    texto += Graficas_1.Graficas.getElement(cont, \"LISTA_ETIQUETAS\", cont - 1);\r\n                    texto += etiqueta.getCstDotD(cont);\r\n                }\r\n                cont += 1;\r\n            }\r\n        }\r\n        texto += \"}\";\r\n        return texto;\r\n    }\r\n}\r\nexports.XmlResultado = XmlResultado;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass NodoControlError {\r\n    constructor(simbolo, tipo, linea, columna, entorno) {\r\n        this.simbolo = simbolo;\r\n        this.tipo = tipo;\r\n        this.linea = linea;\r\n        this.columna = columna;\r\n        this.entorno = entorno;\r\n        //   this.Agregar(this.simbolo,this.tipo,this.linea,this.columna,this.entorno)\r\n    }\r\n}\r\nexports.NodoControlError = NodoControlError;\r\n","// This file can be replaced during build by using the `fileReplacements` array.\r\n// `ng build --prod` replaces `environment.ts` with `environment.prod.ts`.\r\n// The list of file replacements can be found in `angular.json`.\r\n\r\nexport const environment = {\r\n  production: false\r\n};\r\n\r\n/*\r\n * For easier debugging in development mode, you can import the following file\r\n * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.\r\n *\r\n * This import should be commented out in production mode because it will have a negative impact\r\n * on performance if an error is thrown.\r\n */\r\n// import 'zone.js/dist/zone-error';  // Included with Angular CLI.\r\n","import { Component, Input, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-arbol-ast',\n  templateUrl: './arbol-ast.component.html',\n  styleUrls: ['./arbol-ast.component.css']\n})\nexport class ArbolAstComponent implements OnInit {\n\n  @Input() arbolJson:any\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n","<div class=\"row justify-content-center tabla\">\n    <div class=\"col-md-8 tab\">\n        <ul class=\"nav nav-tabs justify-content-center\">\n            <li class=\"nav-item active\">\n                <a class=\"nav-link active\" data-toggle=\"tab\" href=\"#errores\">Arbol Ast</a>\n            </li>\n        </ul>\n    </div>\n    <img src=\"https://media.gettyimages.com/photos/artificial-ingelligence-cpu-empty-landscape-picture-id1132483126?s=2048x2048\">\n</div>\n\n\n<!-- <script src=\"https://d3js.org/d3.v3.min.js\"></script>\n<script src=\"https://vanya.jp.net/vtree/dist/vtree.js\"></script>\n<script>\n  window.onload = () => {\n    var json = `{\"mensaje\":1}`;\n    var vt = new VTree(astDiv);\n    var reader = new VTree.reader.Object();\n    var data = reader.read(JSON.parse(json));\n    vt.data(data).update();\n  };\n</script>\n<div id=\"astDiv\"></div> -->","import { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-tabla-errores',\n  templateUrl: './tabla-errores.component.html',\n  styleUrls: ['./tabla-errores.component.css']\n})\nexport class TablaErroresComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n","<div class=\"row justify-content-center tabla\">\n    <div class=\"col-md-8 tab\">\n        <ul class=\"nav nav-tabs justify-content-center\">\n            <li class=\"nav-item active\">\n                <a class=\"nav-link active\" data-toggle=\"tab\" href=\"#errores\">Tabla de Errores</a>\n            </li>\n        </ul>\n        <div class=\"tab-pane\" id=\"errores\">\n            <div class=\"col-md-12\">\n                <br>\n                <div style=\"width: auto; height: auto;\">\n                    <table class=\"table table-danger table-hover\">\n                        <thead>\n                            <tr>\n                                <td>TIPO</td>\n                                <td>ERROR</td>\n                                <td>FILA</td>\n                                <td>COLUMNA</td>\n                            </tr>\n                        </thead>\n                        <tbody>\n                            <tr>\n                                <td>1</td>\n                                <td>2</td>\n                                <td>3</td>\n                                <td>4</td>\n                            </tr>\n                        </tbody>\n                    </table>\n                </div>\n                <br>\n            </div>\n        </div>\n    </div>\n</div>","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Graficas_1 = require(\"../Graficas/Graficas\");\r\nconst Fila_1 = require(\"./Fila\");\r\nconst Tabla_1 = require(\"./Tabla\");\r\nconst Tipos_1 = require(\"./Tipos\");\r\nconst ControlError_1 = require(\"../Xpath/ControlError\");\r\nconst TipoSeleccion_1 = require(\"../Xpath/TipoSeleccion\");\r\nclass EtiquetaDoble {\r\n    constructor(nombreTagAbre, nombreTagCierre, listaAtributos, cadenaValores, listaHijos, linea, columna, idSent) {\r\n        this.padre = null;\r\n        this.nombreTagAbre = nombreTagAbre;\r\n        this.nombreTagCierre = nombreTagCierre;\r\n        this.listaAtributos = listaAtributos;\r\n        this.tineHijos = listaHijos.length > 0;\r\n        this.cadenaValores = (listaHijos.length == 0) ? cadenaValores : \"\";\r\n        this.listaHijos = (listaHijos.length > 0) ? listaHijos : [];\r\n        this.linea = linea;\r\n        this.columna = columna;\r\n        this.idSent = idSent;\r\n        this.listaAtributos.forEach(atributo => {\r\n            atributo.etiquetaContendora = this;\r\n        });\r\n        this.listaHijos.forEach(hijo => {\r\n            hijo.padre = this;\r\n        });\r\n    }\r\n    imprimir() {\r\n        let texto = \"\";\r\n        texto += \"<\" + this.nombreTagAbre;\r\n        this.listaAtributos.forEach(atributo => {\r\n            texto += \" \" + atributo.imprimir();\r\n        });\r\n        texto += \">\";\r\n        if (this.listaHijos.length > 0) {\r\n            texto += \"\\n\";\r\n        }\r\n        texto += this.cadenaValores;\r\n        this.listaHijos.forEach(hijo => {\r\n            texto += hijo.imprimir();\r\n        });\r\n        texto += \"</\" + this.nombreTagCierre + \"> \\n\";\r\n        return texto;\r\n    }\r\n    getName() {\r\n        return this.nombreTagAbre;\r\n    }\r\n    getAmbito() {\r\n        let listaAmbito = [];\r\n        for (let etiqueta = this.padre; etiqueta != null; etiqueta = etiqueta.padre) {\r\n            listaAmbito.push(etiqueta.getName());\r\n        }\r\n        listaAmbito.push(\"GLOBAL\");\r\n        return listaAmbito;\r\n    }\r\n    getAsTable() {\r\n        let tabla = new Tabla_1.Tabla();\r\n        tabla.addFila(new Fila_1.Fila(this.nombreTagAbre, Tipos_1.Tipos.ETIQUETA_DOBLE, this.getAmbito(), this.linea, this.columna, this.imprimir()));\r\n        this.listaAtributos.forEach(atributo => {\r\n            tabla.addFila(atributo.getAsRowTable());\r\n        });\r\n        this.listaHijos.forEach(etiqueta => {\r\n            etiqueta.getAsTable().filas.forEach(fila => {\r\n                tabla.addFila(fila);\r\n            });\r\n        });\r\n        if (!this.tineHijos) {\r\n            if (this.cadenaValores != \"\") {\r\n                tabla.addFila(new Fila_1.Fila(\"-\", Tipos_1.Tipos.VALOR, [this.getName()].concat(this.getAmbito()), this.linea, this.columna + this.nombreTagAbre.length + 2, this.cadenaValores));\r\n            }\r\n        }\r\n        return tabla;\r\n    }\r\n    getErroresSemanticos() {\r\n        let texto = \"\";\r\n        if (this.nombreTagAbre != this.nombreTagCierre) {\r\n            console.log(\"error arribaa-----------\");\r\n            /*\r\n            \r\n            constructor(simbolo: string, tipo: TipoSeleccion, linea: any, columna: any, entorno: string) {\r\n            */\r\n            texto += `Error(Linea: ${this.linea}, Columna: ${this.columna}): El nombre del tag de apertura no es igual al de cierre.\\n`;\r\n            ControlError_1.ControlError.Agregar(this.nombreTagAbre, TipoSeleccion_1.TipoSeleccion.ERROR_SEMANTICO, this.linea, this.columna, this.padre.getName());\r\n        }\r\n        this.listaAtributos.forEach(atributo => {\r\n            let apariciones = 0;\r\n            for (let atr2 of this.listaAtributos) {\r\n                if (atributo.nombre == atr2.nombre) {\r\n                    apariciones += 1;\r\n                }\r\n                if (apariciones > 1) {\r\n                    console.log(\"error abajo\");\r\n                    texto += `Error(Linea: ${atributo.linea}, Columna: ${atributo.columna}): El atributo '${atributo.nombre}' se encuentra repetido.\\n`;\r\n                    ControlError_1.ControlError.Agregar(atributo.nombre, TipoSeleccion_1.TipoSeleccion.ERROR_SEMANTICO, this.linea, this.columna, this.padre.getName());\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n        this.listaHijos.forEach(hijo => {\r\n            texto += hijo.getErroresSemanticos();\r\n        });\r\n        return texto;\r\n    }\r\n    getCstDotA(idPadre) {\r\n        let texto = \"\";\r\n        texto += Graficas_1.Graficas.getElement(this.idSent, \"ETIQUETA\", idPadre);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 1, \"TAG_APERTURA\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 2, \"AbreTagApertura\", this.idSent + 1);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 3, \"<\" + this.nombreTagAbre, this.idSent + 2);\r\n        if (this.listaAtributos.length > 0) {\r\n            let cont = 4;\r\n            for (let atributo of this.listaAtributos) {\r\n                if (cont - 4 != this.listaAtributos.length - 1) {\r\n                    texto += Graficas_1.Graficas.getElement(this.idSent + cont, \"LISTA_ATRIBUTOS\", this.idSent + cont + 1);\r\n                    texto += atributo.getCstDotA(this.idSent + cont);\r\n                }\r\n                else {\r\n                    texto += Graficas_1.Graficas.getElement(this.idSent + cont, \"LISTA_ATRIBUTOS\", this.idSent + 1);\r\n                    texto += atributo.getCstDotA(this.idSent + cont);\r\n                }\r\n                cont += 1;\r\n            }\r\n        }\r\n        let idSent2 = this.idSent + 4 + this.listaAtributos.length;\r\n        texto += Graficas_1.Graficas.getElement(idSent2 + 1, \"CierreTagApertura\", this.idSent + 1);\r\n        texto += Graficas_1.Graficas.getElement(idSent2 + 2, \">\", idSent2 + 1);\r\n        if (this.listaHijos.length > 0) {\r\n            let cont = 3;\r\n            for (let hijo of this.listaHijos) {\r\n                if (cont - 3 != this.listaHijos.length - 1) {\r\n                    texto += Graficas_1.Graficas.getElement(idSent2 + cont, \"LISTA_ETIQUETAS\", idSent2 + cont + 1);\r\n                    texto += hijo.getCstDotA(idSent2 + cont);\r\n                }\r\n                else {\r\n                    texto += Graficas_1.Graficas.getElement(idSent2 + cont, \"LISTA_ETIQUETAS\", this.idSent);\r\n                    texto += hijo.getCstDotA(idSent2 + cont);\r\n                }\r\n                cont += 1;\r\n            }\r\n        }\r\n        else if (this.cadenaValores != \"\") {\r\n            texto += Graficas_1.Graficas.getElement(idSent2 + 3, \"CadenaValores\", this.idSent);\r\n            texto += Graficas_1.Graficas.getElement(idSent2 + 4, this.cadenaValores, idSent2 + 3);\r\n        }\r\n        let idSent3 = idSent2 + 4 + this.listaHijos.length;\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 1, \"TAG_CIERRE\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 2, \"AbreTagCierre\", idSent3 + 1);\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 3, \"</\" + this.nombreTagCierre, idSent3 + 2);\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 4, \"CierreTagCierre\", idSent3 + 1);\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 5, \">\", idSent3 + 4);\r\n        return texto;\r\n    }\r\n    getCstDotD(idPadre) {\r\n        let texto = \"\";\r\n        texto += Graficas_1.Graficas.getElement(this.idSent, \"ETIQUETA\", idPadre);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 1, \"TAG_APERTURA\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 2, \"AbreTagApertura\", this.idSent + 1);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 3, \"<\" + this.nombreTagAbre, this.idSent + 2);\r\n        if (this.listaAtributos.length > 0) {\r\n            let cont = 4;\r\n            for (let atributo of this.listaAtributos) {\r\n                if (cont === 4) {\r\n                    texto += Graficas_1.Graficas.getElement(this.idSent + cont, \"LISTA_ATRIBUTOS\", this.idSent + 1);\r\n                    texto += atributo.getCstDotA(this.idSent + cont);\r\n                }\r\n                else {\r\n                    texto += Graficas_1.Graficas.getElement(this.idSent + cont, \"LISTA_ATRIBUTOS\", this.idSent + cont - 1);\r\n                    texto += atributo.getCstDotA(this.idSent + cont);\r\n                }\r\n                cont += 1;\r\n            }\r\n        }\r\n        let idSent2 = this.idSent + 4 + this.listaAtributos.length;\r\n        texto += Graficas_1.Graficas.getElement(idSent2 + 1, \"CierreTagApertura\", this.idSent + 1);\r\n        texto += Graficas_1.Graficas.getElement(idSent2 + 2, \">\", idSent2 + 1);\r\n        if (this.listaHijos.length > 0) {\r\n            let cont = 3;\r\n            for (let hijo of this.listaHijos) {\r\n                if (cont === 3) {\r\n                    texto += Graficas_1.Graficas.getElement(idSent2 + cont, \"LISTA_ETIQUETAS\", this.idSent);\r\n                    texto += hijo.getCstDotD(idSent2 + cont);\r\n                }\r\n                else {\r\n                    texto += Graficas_1.Graficas.getElement(idSent2 + cont, \"LISTA_ETIQUETAS\", idSent2 + cont - 1);\r\n                    texto += hijo.getCstDotD(idSent2 + cont);\r\n                }\r\n                cont += 1;\r\n            }\r\n        }\r\n        else if (this.cadenaValores != \"\") {\r\n            texto += Graficas_1.Graficas.getElement(idSent2 + 3, \"CadenaValores\", this.idSent);\r\n            texto += Graficas_1.Graficas.getElement(idSent2 + 4, this.cadenaValores, idSent2 + 3);\r\n        }\r\n        let idSent3 = idSent2 + 4 + this.listaHijos.length;\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 1, \"TAG_CIERRE\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 2, \"AbreTagCierre\", idSent3 + 1);\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 3, \"</\" + this.nombreTagCierre, idSent3 + 2);\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 4, \"CierreTagCierre\", idSent3 + 1);\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 5, \">\", idSent3 + 4);\r\n        return texto;\r\n    }\r\n}\r\nexports.EtiquetaDoble = EtiquetaDoble;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Primitivo_1 = require(\"./Primitivo\");\r\nconst TiposOp_1 = require(\"./TiposOp\");\r\nconst TipoVal_1 = require(\"./TipoVal\");\r\nclass OpBinaria {\r\n    constructor(opIzq, opDer, tipo) {\r\n        this.opIzq = opIzq;\r\n        this.opDer = opDer;\r\n        this.tipo = tipo;\r\n    }\r\n    ejecutar() {\r\n        let primitivoIzq = this.opIzq.ejecutar();\r\n        let primitivoDer = this.opDer.ejecutar();\r\n        switch (this.tipo) {\r\n            case TiposOp_1.TiposOp.SUMA:\r\n                if ((primitivoIzq.tipo === TipoVal_1.TipoVal.ENTERO || primitivoIzq.tipo === TipoVal_1.TipoVal.DECIMAL) &&\r\n                    (primitivoDer.tipo === TipoVal_1.TipoVal.ENTERO || primitivoDer.tipo === TipoVal_1.TipoVal.DECIMAL)) {\r\n                    let res = primitivoIzq.valor + primitivoDer.valor;\r\n                    let tipo = res % 1 === 0 ? TipoVal_1.TipoVal.ENTERO : TipoVal_1.TipoVal.DECIMAL;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.RESTA:\r\n                if ((primitivoIzq.tipo === TipoVal_1.TipoVal.ENTERO || primitivoIzq.tipo === TipoVal_1.TipoVal.DECIMAL) &&\r\n                    (primitivoDer.tipo === TipoVal_1.TipoVal.ENTERO || primitivoDer.tipo === TipoVal_1.TipoVal.DECIMAL)) {\r\n                    let res = primitivoIzq.valor - primitivoDer.valor;\r\n                    let tipo = res % 1 === 0 ? TipoVal_1.TipoVal.ENTERO : TipoVal_1.TipoVal.DECIMAL;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.MULTIPLICACION:\r\n                if ((primitivoIzq.tipo === TipoVal_1.TipoVal.ENTERO || primitivoIzq.tipo === TipoVal_1.TipoVal.DECIMAL) &&\r\n                    (primitivoDer.tipo === TipoVal_1.TipoVal.ENTERO || primitivoDer.tipo === TipoVal_1.TipoVal.DECIMAL)) {\r\n                    let res = primitivoIzq.valor * primitivoDer.valor;\r\n                    let tipo = res % 1 === 0 ? TipoVal_1.TipoVal.ENTERO : TipoVal_1.TipoVal.DECIMAL;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.DIVISION:\r\n                if ((primitivoIzq.tipo === TipoVal_1.TipoVal.ENTERO || primitivoIzq.tipo === TipoVal_1.TipoVal.DECIMAL) &&\r\n                    (primitivoDer.tipo === TipoVal_1.TipoVal.ENTERO || primitivoDer.tipo === TipoVal_1.TipoVal.DECIMAL)) {\r\n                    let res = primitivoIzq.valor / primitivoDer.valor;\r\n                    let tipo = res % 1 === 0 ? TipoVal_1.TipoVal.ENTERO : TipoVal_1.TipoVal.DECIMAL;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.MODULO:\r\n                if ((primitivoIzq.tipo === TipoVal_1.TipoVal.ENTERO || primitivoIzq.tipo === TipoVal_1.TipoVal.DECIMAL) &&\r\n                    (primitivoDer.tipo === TipoVal_1.TipoVal.ENTERO || primitivoDer.tipo === TipoVal_1.TipoVal.DECIMAL)) {\r\n                    let res = primitivoIzq.valor % primitivoDer.valor;\r\n                    let tipo = res % 1 === 0 ? TipoVal_1.TipoVal.ENTERO : TipoVal_1.TipoVal.DECIMAL;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.AND:\r\n                if (primitivoIzq.tipo === TipoVal_1.TipoVal.BOLEANO && primitivoDer.tipo === TipoVal_1.TipoVal.BOLEANO) {\r\n                    let res = primitivoIzq.valor && primitivoDer.valor;\r\n                    let tipo = TipoVal_1.TipoVal.BOLEANO;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.OR:\r\n                if (primitivoIzq.tipo === TipoVal_1.TipoVal.BOLEANO && primitivoDer.tipo === TipoVal_1.TipoVal.BOLEANO) {\r\n                    let res = primitivoIzq.valor || primitivoDer.valor;\r\n                    let tipo = TipoVal_1.TipoVal.BOLEANO;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.MAYOR_QUE:\r\n                if (primitivoIzq.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA] &&\r\n                    primitivoDer.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA]) {\r\n                    let res = primitivoIzq.valor > primitivoDer.valor;\r\n                    let tipo = TipoVal_1.TipoVal.BOLEANO;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.MENOR_QUE:\r\n                if (primitivoIzq.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA] &&\r\n                    primitivoDer.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA]) {\r\n                    let res = primitivoIzq.valor < primitivoDer.valor;\r\n                    let tipo = TipoVal_1.TipoVal.BOLEANO;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.MAYOR_IGUAL:\r\n                if (primitivoIzq.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA] &&\r\n                    primitivoDer.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA]) {\r\n                    let res = primitivoIzq.valor >= primitivoDer.valor;\r\n                    let tipo = TipoVal_1.TipoVal.BOLEANO;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.MENOR_IGUAL:\r\n                if (primitivoIzq.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA] &&\r\n                    primitivoDer.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA]) {\r\n                    let res = primitivoIzq.valor <= primitivoDer.valor;\r\n                    let tipo = TipoVal_1.TipoVal.BOLEANO;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.NO_IGUAL:\r\n                if (primitivoIzq.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA] &&\r\n                    primitivoDer.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA]) {\r\n                    let res = primitivoIzq.valor != primitivoDer.valor;\r\n                    let tipo = TipoVal_1.TipoVal.BOLEANO;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n        }\r\n    }\r\n}\r\nexports.OpBinaria = OpBinaria;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Graficas_1 = require(\"../Graficas/Graficas\");\r\nconst Fila_1 = require(\"./Fila\");\r\nconst Tipos_1 = require(\"./Tipos\");\r\nclass Atributo {\r\n    constructor(nombre, valor, linea, columna, idSent) {\r\n        this.etiquetaContendora = null;\r\n        this.nombre = nombre;\r\n        this.valor = valor;\r\n        this.linea = linea;\r\n        this.columna = columna;\r\n        this.idSent = idSent;\r\n    }\r\n    getAmbito() {\r\n        let listaAmbito = [];\r\n        for (let etiqueta = this.etiquetaContendora; etiqueta != null; etiqueta = etiqueta.padre) {\r\n            listaAmbito.push(etiqueta.getName());\r\n        }\r\n        listaAmbito.push(\"GLOBAL\");\r\n        return listaAmbito;\r\n    }\r\n    getAsRowTable() {\r\n        return (new Fila_1.Fila(this.nombre, Tipos_1.Tipos.ATRIBUTO, this.getAmbito(), this.linea, this.columna, this.imprimir()));\r\n    }\r\n    imprimir() {\r\n        let texto = \"\";\r\n        texto = this.nombre + \"=\" + this.valor;\r\n        return texto;\r\n    }\r\n    getCstDotA(idPadre) {\r\n        let texto = \"\";\r\n        texto += Graficas_1.Graficas.getElement(this.idSent, \"ATRIBUTO\", idPadre);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 1, \"NombreAtributo\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 2, this.nombre, this.idSent + 1);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 4, \"IgualAtributo\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 5, \"=\", this.idSent + 4);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 6, \"ValorAtributo\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 7, this.valor.split(\"\\\"\").join(\"\"), this.idSent + 6);\r\n        return texto;\r\n    }\r\n}\r\nexports.Atributo = Atributo;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst TipoSeleccion_1 = require(\"../Xpath/TipoSeleccion\");\r\nconst TipoVal_1 = require(\"../Xpath/TipoVal\");\r\nfunction sonAmbitosIguales(ambito1, ambito2) {\r\n    if (ambito1.length === ambito2.length) {\r\n        for (let i = 0; i < ambito1.length; i++) {\r\n            if (ambito1[i] != ambito2[i]) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nfunction esSimboloIgual(elemBusqueda, fila) {\r\n    if (elemBusqueda.nombre == fila.nombre &&\r\n        sonAmbitosIguales(elemBusqueda.listaAmbito, fila.listaAmbito)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nclass Tabla {\r\n    constructor() {\r\n        this.filas = [];\r\n    }\r\n    addFila(fila) {\r\n        this.filas.push(fila);\r\n    }\r\n    buscar(resXpath, elemBusqueda = {\r\n        nombre: \"\",\r\n        tipo: \"\",\r\n        listaAmbito: ['GLOBAL'],\r\n        selector: \"/\",\r\n        inidiceRestringido: false,\r\n        indice: 0\r\n    }) {\r\n        let texto = \"\";\r\n        for (let set of resXpath) {\r\n            if (set.tipo === TipoSeleccion_1.TipoSeleccion.ACCESO_NODO_RAIZ && set.predicado == null) {\r\n                for (let fila of this.filas) {\r\n                    if (fila.nombre === set.id && fila.listaAmbito[0] === 'GLOBAL') {\r\n                        texto += fila.valor;\r\n                    }\r\n                }\r\n            }\r\n            if (set.tipo === TipoSeleccion_1.TipoSeleccion.SELECT_NODOS_FROM_NODO) {\r\n                elemBusqueda.nombre = set.id;\r\n                if (set.selector === \"//\" && elemBusqueda.listaAmbito.length === 1 && set.next == null) {\r\n                    elemBusqueda.selector = \"//\";\r\n                }\r\n                if (set.predicado != null) {\r\n                    let opBinaria = set.predicado;\r\n                    let res = opBinaria.ejecutar();\r\n                    if (res.tipo === TipoVal_1.TipoVal.ENTERO) {\r\n                        elemBusqueda.inidiceRestringido = true;\r\n                        elemBusqueda.indice = res.valor - 1;\r\n                    }\r\n                }\r\n                if (set.next != null) {\r\n                    elemBusqueda.listaAmbito.unshift(set.id);\r\n                    texto += this.buscar([set.next], elemBusqueda);\r\n                }\r\n                else {\r\n                    let cont = 0;\r\n                    for (let fila of this.filas) {\r\n                        if (esSimboloIgual(elemBusqueda, fila) || (elemBusqueda.listaAmbito.length === 1) && elemBusqueda.nombre === fila.nombre) {\r\n                            let condicion = elemBusqueda.inidiceRestringido ? cont === elemBusqueda.indice : true;\r\n                            texto += fila.valor;\r\n                            cont += 1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (set.tipo === TipoSeleccion_1.TipoSeleccion.SELECT_NODOS_FROM_NODO) {\r\n            }\r\n            elemBusqueda = {\r\n                nombre: \"\",\r\n                tipo: \"\",\r\n                listaAmbito: ['GLOBAL'],\r\n                selector: \"/\",\r\n                inidiceRestringido: false,\r\n                indice: 0\r\n            };\r\n            texto += \"\\n\";\r\n        }\r\n        return texto;\r\n    }\r\n}\r\nexports.Tabla = Tabla;\r\n","/* parser generated by jison 0.4.18 */\r\n/*\r\n  Returns a Parser object of the following structure:\r\n\r\n  Parser: {\r\n    yy: {}\r\n  }\r\n\r\n  Parser.prototype: {\r\n    yy: {},\r\n    trace: function(),\r\n    symbols_: {associative list: name ==> number},\r\n    terminals_: {associative list: number ==> name},\r\n    productions_: [...],\r\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\r\n    table: [...],\r\n    defaultActions: {...},\r\n    parseError: function(str, hash),\r\n    parse: function(input),\r\n\r\n    lexer: {\r\n        EOF: 1,\r\n        parseError: function(str, hash),\r\n        setInput: function(input),\r\n        input: function(),\r\n        unput: function(str),\r\n        more: function(),\r\n        less: function(n),\r\n        pastInput: function(),\r\n        upcomingInput: function(),\r\n        showPosition: function(),\r\n        test_match: function(regex_match_array, rule_index),\r\n        next: function(),\r\n        lex: function(),\r\n        begin: function(condition),\r\n        popState: function(),\r\n        _currentRules: function(),\r\n        topState: function(),\r\n        pushState: function(condition),\r\n\r\n        options: {\r\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\r\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\r\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\r\n        },\r\n\r\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\r\n        rules: [...],\r\n        conditions: {associative list: name ==> set},\r\n    }\r\n  }\r\n\r\n\r\n  token location info (@$, _$, etc.): {\r\n    first_line: n,\r\n    last_line: n,\r\n    first_column: n,\r\n    last_column: n,\r\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\r\n  }\r\n\r\n\r\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\r\n    text:        (matched text)\r\n    token:       (the produced terminal token, if any)\r\n    line:        (yylineno)\r\n  }\r\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\r\n    loc:         (yylloc)\r\n    expected:    (string describing the set of expected tokens)\r\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\r\n  }\r\n*/\r\nvar xmlD = (function () {\r\n    var o = function (k, v, o, l) { for (o = o || {}, l = k.length; l--; o[k[l]] = v)\r\n        ; return o; }, $V0 = [1, 8], $V1 = [1, 9], $V2 = [1, 14], $V3 = [6, 19], $V4 = [2, 5], $V5 = [1, 21], $V6 = [2, 6, 12, 19], $V7 = [14, 22, 24], $V8 = [2, 24], $V9 = [2, 12, 16, 19], $Va = [2, 12];\r\n    var parser = { trace: function trace() { },\r\n        yy: {},\r\n        symbols_: { \"error\": 2, \"XML\": 3, \"TAG_CONFIGURACION\": 4, \"LISTA_ETIQUETAS\": 5, \"EOF\": 6, \"ETIQUETA\": 7, \"ListaEtiqueta\": 8, \"TAG_APERTURA\": 9, \"MenuEtiqueta\": 10, \"TAG_UNICO\": 11, \"AbreTagApertura\": 12, \"DELIMITADOR\": 13, \"CierreTagApertura\": 14, \"TAG_CIERRE\": 15, \"CadenaValores\": 16, \"MENU_TAG_APERTURA\": 17, \"LISTA_ATRIBUTOS\": 18, \"AbreTagCierre\": 19, \"CierreTagCierre\": 20, \"MENU_TAG_UNICO\": 21, \"CierreTagUnico\": 22, \"AbreTagConf\": 23, \"CierreTagConf\": 24, \"ATRIBUTO\": 25, \"ListaA\": 26, \"NombreAtributo\": 27, \"IgualAtributo\": 28, \"ValorAtributo\": 29, \"$accept\": 0, \"$end\": 1 },\r\n        terminals_: { 2: \"error\", 6: \"EOF\", 12: \"AbreTagApertura\", 14: \"CierreTagApertura\", 16: \"CadenaValores\", 19: \"AbreTagCierre\", 20: \"CierreTagCierre\", 22: \"CierreTagUnico\", 23: \"AbreTagConf\", 24: \"CierreTagConf\", 27: \"NombreAtributo\", 28: \"IgualAtributo\", 29: \"ValorAtributo\" },\r\n        productions_: [0, [3, 3], [3, 2], [5, 2], [8, 2], [8, 0], [7, 2], [7, 1], [7, 2], [13, 1], [13, 1], [10, 2], [10, 2], [10, 1], [9, 2], [17, 2], [17, 1], [15, 2], [11, 2], [21, 2], [21, 1], [4, 3], [18, 2], [26, 2], [26, 0], [25, 3]],\r\n        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\r\n            /* this == yyval */\r\n            var $0 = $$.length - 1;\r\n            switch (yystate) {\r\n                case 1:\r\n                    this.$ = new XmlResultado($$[$0 - 2], $$[$0 - 1]);\r\n                    return this.$;\r\n                    new ReporteGramatica(\"XML -> TAG_CONFIGURACION LISTA_ETIQUETAS EOF\", \"XML.val = TAG_CONFIGURACION.val+LISTA_ETIQUETAS.val\");\r\n                    break;\r\n                case 2:\r\n                    this.$ = new XmlResultado(null, $$[$0]);\r\n                    return this.$;\r\n                    new ReporteGramatica(\"XML -> N LISTA_ETIQUETAS EOF\", \"XML.val = LISTA_ETIQUETAS.val\");\r\n                    break;\r\n                case 3:\r\n                    $$[$0].push($$[$0 - 1]);\r\n                    this.$ = $$[$0];\r\n                    new ReporteGramatica(\"LISTA_ETIQUETAS -> ETIQUETA ListaEtiqueta \", \"LISTA_ETIQUETAS.val=ListaEtiqueta.val--- ListaEtiqueta = new Array(ETIQUETA)     ////    ListaEtiqueta.push(ETIQUETA.val)\");\r\n                    break;\r\n                case 4:\r\n                    $$[$0].push($$[$0 - 1]);\r\n                    this.$ = $$[$0];\r\n                    new ReporteGramatica(\"ListaEtiqueta -> ETIQUETA ListaEtiqueta \", \"    ListaEtiqueta.push(ETIQUETA.val)\");\r\n                    break;\r\n                case 5:\r\n                    this.$ = [];\r\n                    new ReporteGramatica(\"ListaEtiqueta -> epsilon \", \"  ListaEtiqueta.val = []\");\r\n                    break;\r\n                case 6:\r\n                    this.$ = new EtiquetaDoble($$[$0 - 1].nombreTagApertura, $$[$0].nombreTagCierre, $$[$0 - 1].listaAtributos, $$[$0].cadena, $$[$0].listaEtiqueta, _$[$0 - 1].first_line, _$[$0 - 1].first_column, getId());\r\n                    new ReporteGramatica(\"ETIQUETA -> TAG_APERTURA MenuEtiqueta \", \" ETIQUTA.val= new EtiquetaDoble(TAG_APERTURA.val, MenuEtiqueta.val)\");\r\n                    break;\r\n                case 7:\r\n                    this.$ = $$[$0];\r\n                    new ReporteGramatica(\"ETIQUETA -> TAG_UNICO    \", \" ETIQUTA.val= TAG_UNICO.val\");\r\n                    break;\r\n                case 8:\r\n                    this.$ = new ControlError(yytext, TipoSeleccion.ERROR_SINTACTICO, this._$.first_line, this._$.first_column, \"XmlDEscendiente\");\r\n                    break;\r\n                case 9:\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 10:\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 11:\r\n                    this.$ = {\r\n                        nombreTagCierre: $$[$0],\r\n                        listaEtiqueta: $$[$0 - 1],\r\n                        cadena: ''\r\n                    };\r\n                    new ReporteGramatica(\"MenuEtiqueta -> LISTA_ETIQUETAS TAG_CIERRE    \", \" MenuEtiqueta.val= LISTA_ETIQUETAS.val +TAG_CIERRE.val\");\r\n                    break;\r\n                case 12:\r\n                    this.$ = {\r\n                        nombreTagCierre: $$[$0],\r\n                        listaEtiqueta: [],\r\n                        cadena: $$[$0 - 1]\r\n                    };\r\n                    new ReporteGramatica(\"MenuEtiqueta ->  CadenaValores TAG_CIERRE  \", \" MenuEtiqueta.val= CadenaValores.lexval +TAG_CIERRE.val\");\r\n                    break;\r\n                case 13:\r\n                    this.$ = {\r\n                        nombreTagCierre: $$[$0],\r\n                        listaEtiqueta: [],\r\n                        cadena: ''\r\n                    };\r\n                    new ReporteGramatica(\"MenuEtiqueta ->   TAG_CIERRE  \", \" MenuEtiqueta.val=TAG_CIERRE.val\");\r\n                    break;\r\n                case 14:\r\n                    this.$ = {\r\n                        nombreTagApertura: formatTagName($$[$0 - 1]),\r\n                        listaAtributos: $$[$0].listaAtributos_\r\n                    };\r\n                    new ReporteGramatica(\"TAG_APERTURA ->   AbreTagApertura MENU_TAG_APERTURA \", \" TAG_APERTURA.val=  AbreTagApertura.lexval+ MENU_TAG_APERTURA.val\");\r\n                    break;\r\n                case 15:\r\n                    this.$ = {\r\n                        listaAtributos_: $$[$0 - 1]\r\n                    };\r\n                    new ReporteGramatica(\"MENU_TAG_APERTURA: ->   LISTA_ATRIBUTOS CierreTagApertura \", \" MENU_TAG_APERTURA.val=  LISTA_ATRIBUTOS.val+ CierreTagApertura.lexval\");\r\n                    break;\r\n                case 16:\r\n                    this.$ = {\r\n                        listaAtributos_: []\r\n                    };\r\n                    new ReporteGramatica(\"MENU_TAG_APERTURA: ->    CierreTagApertura \", \" MENU_TAG_APERTURA.val=   CierreTagApertura.lexval\");\r\n                    break;\r\n                case 17:\r\n                    this.$ = formatTagName(formatTagName($$[$0 - 1]));\r\n                    new ReporteGramatica(\"TAG_CIERRE ->AbreTagApertura CierreTagApertura \", \"TAG_CIERRE.val =AbreTagApertura.lexval  + CierreTagApertura.lexval \");\r\n                    break;\r\n                case 18:\r\n                    this.$ = new EtiquetaSimple(formatTagName($$[$0 - 1]), $$[$0].listaAtributos_unico, _$[$0 - 1].first_line, _$[$0 - 1].first_column, getId());\r\n                    new ReporteGramatica(\"TAG_UNICO: ->    AbreTagApertura MENU_TAG_UNICO\", \" TAG_UNICO.val=   AbreTagApertura.lexval+ MENU_TAG_UNICO.val\");\r\n                    break;\r\n                case 19:\r\n                    this.$ = {\r\n                        listaAtributos_unico: $$[$0 - 1]\r\n                    };\r\n                    new ReporteGramatica(\"MENU_TAG_UNICO: ->    LISTA_ATRIBUTOS CierreTagUnico\", \" MENU_TAG_UNICO.val=   LISTA_ATRIBUTOS.val +CierreTagUnico.lexval\");\r\n                    break;\r\n                case 20:\r\n                    this.$ = {\r\n                        listaAtributos_unico: []\r\n                    };\r\n                    new ReporteGramatica(\"MENU_TAG_UNICO: ->    CierreTagUnico\", \" MENU_TAG_UNICO.val=   CierreTagUnico.lexval\");\r\n                    break;\r\n                case 21:\r\n                    this.$ = new EtiquetaInicio($$[$0 - 1], _$[$0 - 2].first_line, _$[$0 - 2].first_column, getId());\r\n                    new ReporteGramatica(\"TAG_CONFIGURACION: ->    AbreTagConf LISTA_ATRIBUTOS CierreTagConf \", \" TAG_CONFIGURACION.val=     AbreTagConf.lexval LISTA_ATRIBUTOS.val CierreTagConf.lexval \");\r\n                    break;\r\n                case 22:\r\n                    $$[$0].push($$[$0 - 1]);\r\n                    this.$ = $$[$0];\r\n                    new ReporteGramatica(\"LISTA_ATRIBUTOS -> ATRIBUTO ListaA \", \"LISTA_ATRIBUTOS.val=ListaA.val--- ListaA = new Array(ATRIBUTO)     ////    ListaA.push(ATRIBUTO.val)\");\r\n                    break;\r\n                case 23:\r\n                    $$[$0].push($$[$0 - 1]);\r\n                    this.$ = $$[$0];\r\n                    new ReporteGramatica(\"ListaA -> ATRIBUTO ListaA \", \"    ListaA.push(ATRIBUTO.val)\");\r\n                    break;\r\n                case 24:\r\n                    this.$ = [];\r\n                    new ReporteGramatica(\"ListaA -> epsilon \", \"  ListaA.val = []\");\r\n                    break;\r\n                case 25:\r\n                    this.$ = new Atributo($$[$0 - 2], $$[$0], _$[$0 - 2].first_line, _$[$0 - 2].first_column, getId());\r\n                    new ReporteGramatica(\"ATRIBUTO -> NombreAtributo IgualAtributo ValorAtributo  \", \"ATRIBUTO.val=new Atributo (NombreAtributo.lexval,IgualAtributo.lexval,ValorAtributo.lexval)\");\r\n                    break;\r\n            }\r\n        },\r\n        table: [{ 2: $V0, 3: 1, 4: 2, 5: 3, 7: 5, 9: 6, 11: 7, 12: $V1, 23: [1, 4] }, { 1: [3] }, { 2: $V0, 5: 10, 7: 5, 9: 6, 11: 7, 12: $V1 }, { 6: [1, 11] }, { 18: 12, 25: 13, 27: $V2 }, o($V3, $V4, { 9: 6, 11: 7, 8: 15, 7: 16, 2: $V0, 12: $V1 }), { 2: $V0, 5: 18, 7: 5, 9: 6, 10: 17, 11: 7, 12: $V1, 15: 20, 16: [1, 19], 19: $V5 }, o($V6, [2, 7]), { 12: [1, 22] }, { 14: [1, 26], 17: 23, 18: 25, 21: 24, 22: [1, 27], 25: 13, 27: $V2 }, { 6: [1, 28] }, { 1: [2, 2] }, { 24: [1, 29] }, o($V7, $V8, { 26: 30, 25: 31, 27: $V2 }), { 28: [1, 32] }, o($V3, [2, 3]), o($V3, $V4, { 9: 6, 11: 7, 7: 16, 8: 33, 2: $V0, 12: $V1 }), o($V6, [2, 6]), { 15: 34, 19: $V5 }, { 15: 35, 19: $V5 }, o($V6, [2, 13]), { 20: [1, 36] }, o($V6, [2, 8]), o($V9, [2, 14]), o($V6, [2, 18]), { 14: [1, 37], 22: [1, 38] }, o($V9, [2, 16]), o($V6, [2, 20]), { 1: [2, 1] }, o($Va, [2, 21]), o($V7, [2, 22]), o($V7, $V8, { 25: 31, 26: 39, 27: $V2 }), { 29: [1, 40] }, o($V3, [2, 4]), o($V6, [2, 11]), o($V6, $Va), o($V6, [2, 17]), o($V9, [2, 15]), o($V6, [2, 19]), o($V7, [2, 23]), o([14, 22, 24, 27], [2, 25])],\r\n        defaultActions: { 11: [2, 2], 28: [2, 1] },\r\n        parseError: function parseError(str, hash) {\r\n            if (hash.recoverable) {\r\n                this.trace(str);\r\n            }\r\n            else {\r\n                var error = new Error(str);\r\n                error.hash = hash;\r\n                throw error;\r\n            }\r\n        },\r\n        parse: function parse(input) {\r\n            var self = this, stack = [0], tstack = [], // token stack\r\n            vstack = [null], // semantic value stack\r\n            lstack = [], // location stack\r\n            table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\r\n            var args = lstack.slice.call(arguments, 1);\r\n            //this.reductionCount = this.shiftCount = 0;\r\n            var lexer = Object.create(this.lexer);\r\n            var sharedState = { yy: {} };\r\n            // copy state\r\n            for (var k in this.yy) {\r\n                if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\r\n                    sharedState.yy[k] = this.yy[k];\r\n                }\r\n            }\r\n            lexer.setInput(input, sharedState.yy);\r\n            sharedState.yy.lexer = lexer;\r\n            sharedState.yy.parser = this;\r\n            if (typeof lexer.yylloc == 'undefined') {\r\n                lexer.yylloc = {};\r\n            }\r\n            var yyloc = lexer.yylloc;\r\n            lstack.push(yyloc);\r\n            var ranges = lexer.options && lexer.options.ranges;\r\n            if (typeof sharedState.yy.parseError === 'function') {\r\n                this.parseError = sharedState.yy.parseError;\r\n            }\r\n            else {\r\n                this.parseError = Object.getPrototypeOf(this).parseError;\r\n            }\r\n            function popStack(n) {\r\n                stack.length = stack.length - 2 * n;\r\n                vstack.length = vstack.length - n;\r\n                lstack.length = lstack.length - n;\r\n            }\r\n            _token_stack: var lex = function () {\r\n                var token;\r\n                token = lexer.lex() || EOF;\r\n                // if token isn't its numeric value, convert\r\n                if (typeof token !== 'number') {\r\n                    token = self.symbols_[token] || token;\r\n                }\r\n                return token;\r\n            };\r\n            var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\r\n            while (true) {\r\n                // retreive state number from top of stack\r\n                state = stack[stack.length - 1];\r\n                // use default actions if available\r\n                if (this.defaultActions[state]) {\r\n                    action = this.defaultActions[state];\r\n                }\r\n                else {\r\n                    if (symbol === null || typeof symbol == 'undefined') {\r\n                        symbol = lex();\r\n                    }\r\n                    // read action for current state and first input\r\n                    action = table[state] && table[state][symbol];\r\n                }\r\n                _handle_error: \r\n                // handle parse error\r\n                if (typeof action === 'undefined' || !action.length || !action[0]) {\r\n                    var error_rule_depth;\r\n                    var errStr = '';\r\n                    // Return the rule stack depth where the nearest error rule can be found.\r\n                    // Return FALSE when no error recovery rule was found.\r\n                    function locateNearestErrorRecoveryRule(state) {\r\n                        var stack_probe = stack.length - 1;\r\n                        var depth = 0;\r\n                        // try to recover from error\r\n                        for (;;) {\r\n                            // check for error recovery rule in this state\r\n                            if ((TERROR.toString()) in table[state]) {\r\n                                return depth;\r\n                            }\r\n                            if (state === 0 || stack_probe < 2) {\r\n                                return false; // No suitable error recovery rule available.\r\n                            }\r\n                            stack_probe -= 2; // popStack(1): [symbol, action]\r\n                            state = stack[stack_probe];\r\n                            ++depth;\r\n                        }\r\n                    }\r\n                    if (!recovering) {\r\n                        // first see if there's any chance at hitting an error recovery rule:\r\n                        error_rule_depth = locateNearestErrorRecoveryRule(state);\r\n                        // Report error\r\n                        expected = [];\r\n                        for (p in table[state]) {\r\n                            if (this.terminals_[p] && p > TERROR) {\r\n                                expected.push(\"'\" + this.terminals_[p] + \"'\");\r\n                            }\r\n                        }\r\n                        if (lexer.showPosition) {\r\n                            errStr = 'Parse error on line ' + (yylineno + 1) + \":\\n\" + lexer.showPosition() + \"\\nExpecting \" + expected.join(', ') + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\r\n                        }\r\n                        else {\r\n                            errStr = 'Parse error on line ' + (yylineno + 1) + \": Unexpected \" +\r\n                                (symbol == EOF ? \"end of input\" :\r\n                                    (\"'\" + (this.terminals_[symbol] || symbol) + \"'\"));\r\n                        }\r\n                        this.parseError(errStr, {\r\n                            text: lexer.match,\r\n                            token: this.terminals_[symbol] || symbol,\r\n                            line: lexer.yylineno,\r\n                            loc: yyloc,\r\n                            expected: expected,\r\n                            recoverable: (error_rule_depth !== false)\r\n                        });\r\n                    }\r\n                    else if (preErrorSymbol !== EOF) {\r\n                        error_rule_depth = locateNearestErrorRecoveryRule(state);\r\n                    }\r\n                    // just recovered from another error\r\n                    if (recovering == 3) {\r\n                        if (symbol === EOF || preErrorSymbol === EOF) {\r\n                            throw new Error(errStr || 'Parsing halted while starting to recover from another error.');\r\n                        }\r\n                        // discard current lookahead and grab another\r\n                        yyleng = lexer.yyleng;\r\n                        yytext = lexer.yytext;\r\n                        yylineno = lexer.yylineno;\r\n                        yyloc = lexer.yylloc;\r\n                        symbol = lex();\r\n                    }\r\n                    // try to recover from error\r\n                    if (error_rule_depth === false) {\r\n                        throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');\r\n                    }\r\n                    popStack(error_rule_depth);\r\n                    preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token\r\n                    symbol = TERROR; // insert generic error symbol as new lookahead\r\n                    state = stack[stack.length - 1];\r\n                    action = table[state] && table[state][TERROR];\r\n                    recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\r\n                }\r\n                // this shouldn't happen, unless resolve defaults are off\r\n                if (action[0] instanceof Array && action.length > 1) {\r\n                    throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\r\n                }\r\n                switch (action[0]) {\r\n                    case 1: // shift\r\n                        //this.shiftCount++;\r\n                        stack.push(symbol);\r\n                        vstack.push(lexer.yytext);\r\n                        lstack.push(lexer.yylloc);\r\n                        stack.push(action[1]); // push state\r\n                        symbol = null;\r\n                        if (!preErrorSymbol) { // normal execution/no error\r\n                            yyleng = lexer.yyleng;\r\n                            yytext = lexer.yytext;\r\n                            yylineno = lexer.yylineno;\r\n                            yyloc = lexer.yylloc;\r\n                            if (recovering > 0) {\r\n                                recovering--;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // error just occurred, resume old lookahead f/ before error\r\n                            symbol = preErrorSymbol;\r\n                            preErrorSymbol = null;\r\n                        }\r\n                        break;\r\n                    case 2:\r\n                        // reduce\r\n                        //this.reductionCount++;\r\n                        len = this.productions_[action[1]][1];\r\n                        // perform semantic action\r\n                        yyval.$ = vstack[vstack.length - len]; // default to $$ = $1\r\n                        // default location, uses first token for firsts, last for lasts\r\n                        yyval._$ = {\r\n                            first_line: lstack[lstack.length - (len || 1)].first_line,\r\n                            last_line: lstack[lstack.length - 1].last_line,\r\n                            first_column: lstack[lstack.length - (len || 1)].first_column,\r\n                            last_column: lstack[lstack.length - 1].last_column\r\n                        };\r\n                        if (ranges) {\r\n                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];\r\n                        }\r\n                        r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));\r\n                        if (typeof r !== 'undefined') {\r\n                            return r;\r\n                        }\r\n                        // pop off stack\r\n                        if (len) {\r\n                            stack = stack.slice(0, -1 * len * 2);\r\n                            vstack = vstack.slice(0, -1 * len);\r\n                            lstack = lstack.slice(0, -1 * len);\r\n                        }\r\n                        stack.push(this.productions_[action[1]][0]); // push nonterminal (reduce)\r\n                        vstack.push(yyval.$);\r\n                        lstack.push(yyval._$);\r\n                        // goto new state = table[STATE][NONTERMINAL]\r\n                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\r\n                        stack.push(newState);\r\n                        break;\r\n                    case 3:\r\n                        // accept\r\n                        return true;\r\n                }\r\n            }\r\n            return true;\r\n        } };\r\n    const { EtiquetaDoble } = require('../Xml/EtiquetaDoble');\r\n    const { EtiquetaSimple } = require('../Xml/EtiquetaSimple');\r\n    const { EtiquetaInicio } = require('../Xml/EtiquetaInicio');\r\n    const { Atributo } = require('../Xml/Atributo');\r\n    const { XmlResultado } = require('../Xml/XmlResultado');\r\n    const { ControlError } = require('../Xpath/ControlError');\r\n    const { ReporteGramatica } = require('../Reportes/ReporteGramatica');\r\n    let idSent = 1;\r\n    function getId() {\r\n        idSent += 100;\r\n        return idSent;\r\n    }\r\n    function formatTagName(AbreTagApertura) {\r\n        return AbreTagApertura.substring(1, AbreTagApertura.length);\r\n    }\r\n    listaError = [];\r\n    /* generated by jison-lex 0.3.4 */\r\n    var lexer = (function () {\r\n        var lexer = ({\r\n            EOF: 1,\r\n            parseError: function parseError(str, hash) {\r\n                if (this.yy.parser) {\r\n                    this.yy.parser.parseError(str, hash);\r\n                }\r\n                else {\r\n                    throw new Error(str);\r\n                }\r\n            },\r\n            // resets the lexer, sets new input\r\n            setInput: function (input, yy) {\r\n                this.yy = yy || this.yy || {};\r\n                this._input = input;\r\n                this._more = this._backtrack = this.done = false;\r\n                this.yylineno = this.yyleng = 0;\r\n                this.yytext = this.matched = this.match = '';\r\n                this.conditionStack = ['INITIAL'];\r\n                this.yylloc = {\r\n                    first_line: 1,\r\n                    first_column: 0,\r\n                    last_line: 1,\r\n                    last_column: 0\r\n                };\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [0, 0];\r\n                }\r\n                this.offset = 0;\r\n                return this;\r\n            },\r\n            // consumes and returns one char from the input\r\n            input: function () {\r\n                var ch = this._input[0];\r\n                this.yytext += ch;\r\n                this.yyleng++;\r\n                this.offset++;\r\n                this.match += ch;\r\n                this.matched += ch;\r\n                var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\r\n                if (lines) {\r\n                    this.yylineno++;\r\n                    this.yylloc.last_line++;\r\n                }\r\n                else {\r\n                    this.yylloc.last_column++;\r\n                }\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range[1]++;\r\n                }\r\n                this._input = this._input.slice(1);\r\n                return ch;\r\n            },\r\n            // unshifts one char (or a string) into the input\r\n            unput: function (ch) {\r\n                var len = ch.length;\r\n                var lines = ch.split(/(?:\\r\\n?|\\n)/g);\r\n                this._input = ch + this._input;\r\n                this.yytext = this.yytext.substr(0, this.yytext.length - len);\r\n                //this.yyleng -= len;\r\n                this.offset -= len;\r\n                var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\r\n                this.match = this.match.substr(0, this.match.length - 1);\r\n                this.matched = this.matched.substr(0, this.matched.length - 1);\r\n                if (lines.length - 1) {\r\n                    this.yylineno -= lines.length - 1;\r\n                }\r\n                var r = this.yylloc.range;\r\n                this.yylloc = {\r\n                    first_line: this.yylloc.first_line,\r\n                    last_line: this.yylineno + 1,\r\n                    first_column: this.yylloc.first_column,\r\n                    last_column: lines ?\r\n                        (lines.length === oldLines.length ? this.yylloc.first_column : 0)\r\n                            + oldLines[oldLines.length - lines.length].length - lines[0].length :\r\n                        this.yylloc.first_column - len\r\n                };\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];\r\n                }\r\n                this.yyleng = this.yytext.length;\r\n                return this;\r\n            },\r\n            // When called from action, caches matched text and appends it on next action\r\n            more: function () {\r\n                this._more = true;\r\n                return this;\r\n            },\r\n            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\r\n            reject: function () {\r\n                if (this.options.backtrack_lexer) {\r\n                    this._backtrack = true;\r\n                }\r\n                else {\r\n                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\r\n                        text: \"\",\r\n                        token: null,\r\n                        line: this.yylineno\r\n                    });\r\n                }\r\n                return this;\r\n            },\r\n            // retain first n characters of the match\r\n            less: function (n) {\r\n                this.unput(this.match.slice(n));\r\n            },\r\n            // displays already matched input, i.e. for error messages\r\n            pastInput: function () {\r\n                var past = this.matched.substr(0, this.matched.length - this.match.length);\r\n                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\\n/g, \"\");\r\n            },\r\n            // displays upcoming input, i.e. for error messages\r\n            upcomingInput: function () {\r\n                var next = this.match;\r\n                if (next.length < 20) {\r\n                    next += this._input.substr(0, 20 - next.length);\r\n                }\r\n                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\r\n            },\r\n            // displays the character position where the lexing error occurred, i.e. for error messages\r\n            showPosition: function () {\r\n                var pre = this.pastInput();\r\n                var c = new Array(pre.length + 1).join(\"-\");\r\n                return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\r\n            },\r\n            // test the lexed token: return FALSE when not a match, otherwise return token\r\n            test_match: function (match, indexed_rule) {\r\n                var token, lines, backup;\r\n                if (this.options.backtrack_lexer) {\r\n                    // save context\r\n                    backup = {\r\n                        yylineno: this.yylineno,\r\n                        yylloc: {\r\n                            first_line: this.yylloc.first_line,\r\n                            last_line: this.last_line,\r\n                            first_column: this.yylloc.first_column,\r\n                            last_column: this.yylloc.last_column\r\n                        },\r\n                        yytext: this.yytext,\r\n                        match: this.match,\r\n                        matches: this.matches,\r\n                        matched: this.matched,\r\n                        yyleng: this.yyleng,\r\n                        offset: this.offset,\r\n                        _more: this._more,\r\n                        _input: this._input,\r\n                        yy: this.yy,\r\n                        conditionStack: this.conditionStack.slice(0),\r\n                        done: this.done\r\n                    };\r\n                    if (this.options.ranges) {\r\n                        backup.yylloc.range = this.yylloc.range.slice(0);\r\n                    }\r\n                }\r\n                lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\r\n                if (lines) {\r\n                    this.yylineno += lines.length;\r\n                }\r\n                this.yylloc = {\r\n                    first_line: this.yylloc.last_line,\r\n                    last_line: this.yylineno + 1,\r\n                    first_column: this.yylloc.last_column,\r\n                    last_column: lines ?\r\n                        lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\r\n                        this.yylloc.last_column + match[0].length\r\n                };\r\n                this.yytext += match[0];\r\n                this.match += match[0];\r\n                this.matches = match;\r\n                this.yyleng = this.yytext.length;\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [this.offset, this.offset += this.yyleng];\r\n                }\r\n                this._more = false;\r\n                this._backtrack = false;\r\n                this._input = this._input.slice(match[0].length);\r\n                this.matched += match[0];\r\n                token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\r\n                if (this.done && this._input) {\r\n                    this.done = false;\r\n                }\r\n                if (token) {\r\n                    return token;\r\n                }\r\n                else if (this._backtrack) {\r\n                    // recover context\r\n                    for (var k in backup) {\r\n                        this[k] = backup[k];\r\n                    }\r\n                    return false; // rule action called reject() implying the next rule should be tested instead.\r\n                }\r\n                return false;\r\n            },\r\n            // return next match in input\r\n            next: function () {\r\n                if (this.done) {\r\n                    return this.EOF;\r\n                }\r\n                if (!this._input) {\r\n                    this.done = true;\r\n                }\r\n                var token, match, tempMatch, index;\r\n                if (!this._more) {\r\n                    this.yytext = '';\r\n                    this.match = '';\r\n                }\r\n                var rules = this._currentRules();\r\n                for (var i = 0; i < rules.length; i++) {\r\n                    tempMatch = this._input.match(this.rules[rules[i]]);\r\n                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\r\n                        match = tempMatch;\r\n                        index = i;\r\n                        if (this.options.backtrack_lexer) {\r\n                            token = this.test_match(tempMatch, rules[i]);\r\n                            if (token !== false) {\r\n                                return token;\r\n                            }\r\n                            else if (this._backtrack) {\r\n                                match = false;\r\n                                continue; // rule action called reject() implying a rule MISmatch.\r\n                            }\r\n                            else {\r\n                                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n                                return false;\r\n                            }\r\n                        }\r\n                        else if (!this.options.flex) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (match) {\r\n                    token = this.test_match(match, rules[index]);\r\n                    if (token !== false) {\r\n                        return token;\r\n                    }\r\n                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n                    return false;\r\n                }\r\n                if (this._input === \"\") {\r\n                    return this.EOF;\r\n                }\r\n                else {\r\n                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\r\n                        text: \"\",\r\n                        token: null,\r\n                        line: this.yylineno\r\n                    });\r\n                }\r\n            },\r\n            // return next match that has a token\r\n            lex: function lex() {\r\n                var r = this.next();\r\n                if (r) {\r\n                    return r;\r\n                }\r\n                else {\r\n                    return this.lex();\r\n                }\r\n            },\r\n            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\r\n            begin: function begin(condition) {\r\n                this.conditionStack.push(condition);\r\n            },\r\n            // pop the previously active lexer condition state off the condition stack\r\n            popState: function popState() {\r\n                var n = this.conditionStack.length - 1;\r\n                if (n > 0) {\r\n                    return this.conditionStack.pop();\r\n                }\r\n                else {\r\n                    return this.conditionStack[0];\r\n                }\r\n            },\r\n            // produce the lexer rule set which is active for the currently active lexer condition state\r\n            _currentRules: function _currentRules() {\r\n                if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\r\n                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\r\n                }\r\n                else {\r\n                    return this.conditions[\"INITIAL\"].rules;\r\n                }\r\n            },\r\n            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\r\n            topState: function topState(n) {\r\n                n = this.conditionStack.length - 1 - Math.abs(n || 0);\r\n                if (n >= 0) {\r\n                    return this.conditionStack[n];\r\n                }\r\n                else {\r\n                    return \"INITIAL\";\r\n                }\r\n            },\r\n            // alias for begin(condition)\r\n            pushState: function pushState(condition) {\r\n                this.begin(condition);\r\n            },\r\n            // return the number of states currently on the stack\r\n            stateStackSize: function stateStackSize() {\r\n                return this.conditionStack.length;\r\n            },\r\n            options: { \"case-insensitive\": true },\r\n            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\r\n                var YYSTATE = YY_START;\r\n                switch ($avoiding_name_collisions) {\r\n                    case 0:\r\n                        this.begin(\"Comentario\");\r\n                        break;\r\n                    case 1:\r\n                        break;\r\n                    case 2:\r\n                        break;\r\n                    case 3:\r\n                        this.popState();\r\n                        break;\r\n                    case 4:\r\n                        break;\r\n                    case 5:\r\n                        this.begin(\"TagApertura\");\r\n                        return 23;\r\n                        break;\r\n                    case 6:\r\n                        break;\r\n                    case 7:\r\n                        return 27;\r\n                        break;\r\n                    case 8:\r\n                        return 28;\r\n                        break;\r\n                    case 9:\r\n                        return 29;\r\n                        break;\r\n                    case 10:\r\n                        this.popState();\r\n                        return 24;\r\n                        break;\r\n                    case 11:\r\n                        this.begin(\"TagApertura\");\r\n                        return 12;\r\n                        break;\r\n                    case 12:\r\n                        break;\r\n                    case 13:\r\n                        return 27;\r\n                        break;\r\n                    case 14:\r\n                        return 28;\r\n                        break;\r\n                    case 15:\r\n                        return 29;\r\n                        break;\r\n                    case 16:\r\n                        this.popState();\r\n                        return 14;\r\n                        break;\r\n                    case 17:\r\n                        this.popState();\r\n                        return 22;\r\n                        break;\r\n                    case 18:\r\n                        this.begin(\"TagCierre\");\r\n                        return 19;\r\n                        break;\r\n                    case 19:\r\n                        this.popState();\r\n                        return 20;\r\n                        break;\r\n                    case 20:\r\n                        break;\r\n                    case 21:\r\n                        return 16;\r\n                        break;\r\n                    case 22:\r\n                        return 6;\r\n                        break;\r\n                    case 23:\r\n                        new ControlError(yy_.yytext, TipoSeleccion.ERROR_LEXICO, yy_.yylloc.first_line, yy_.yylloc.first_column, \"XmlDescendente\");\r\n                        break;\r\n                }\r\n            },\r\n            rules: [/^(?:<!--)/i, /^(?:[\\r\\t]+)/i, /^(?:\\n)/i, /^(?:-->)/i, /^(?:[^\"-->\"]+)/i, /^(?:<\\?xml\\b)/i, /^(?:[\\s\\r\\t\\n]+)/i, /^(?:[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:=)/i, /^(?:\"[^\\\"\\n]*\")/i, /^(?:\\?>)/i, /^(?:<[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:[\\s\\r\\t\\n]+)/i, /^(?:[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:=)/i, /^(?:\"[^\\\"\\n]*\")/i, /^(?:>)/i, /^(?:\\/>)/i, /^(?:<\\/[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:>)/i, /^(?:[\\s\\r\\t\\n]+)/i, /^(?:[^<]+)/i, /^(?:$)/i, /^(?:.)/i],\r\n            conditions: { \"TagCierre\": { \"rules\": [19], \"inclusive\": false }, \"TagApertura\": { \"rules\": [6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17], \"inclusive\": false }, \"Comentario\": { \"rules\": [1, 2, 3, 4], \"inclusive\": false }, \"INITIAL\": { \"rules\": [0, 5, 11, 18, 20, 21, 22, 23], \"inclusive\": true } }\r\n        });\r\n        return lexer;\r\n    })();\r\n    parser.lexer = lexer;\r\n    function Parser() {\r\n        this.yy = {};\r\n    }\r\n    Parser.prototype = parser;\r\n    parser.Parser = Parser;\r\n    return new Parser;\r\n})();\r\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\r\n    exports.parser = xmlD;\r\n    exports.Parser = xmlD.Parser;\r\n    exports.parse = function () { return xmlD.parse.apply(xmlD, arguments); };\r\n    exports.main = function commonjsMain(args) {\r\n        if (!args[1]) {\r\n            console.log('Usage: ' + args[0] + ' FILE');\r\n            process.exit(1);\r\n        }\r\n        var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\r\n        return exports.parser.parse(source);\r\n    };\r\n    if (typeof module !== 'undefined' && require.main === module) {\r\n        exports.main(process.argv.slice(1));\r\n    }\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass Primitivo {\r\n    constructor(valor, tipo) {\r\n        this.valor = valor;\r\n        this.tipo = tipo;\r\n    }\r\n    ejecutar() {\r\n        return this;\r\n    }\r\n}\r\nexports.Primitivo = Primitivo;\r\n","/* parser generated by jison 0.4.18 */\r\n/*\r\n  Returns a Parser object of the following structure:\r\n\r\n  Parser: {\r\n    yy: {}\r\n  }\r\n\r\n  Parser.prototype: {\r\n    yy: {},\r\n    trace: function(),\r\n    symbols_: {associative list: name ==> number},\r\n    terminals_: {associative list: number ==> name},\r\n    productions_: [...],\r\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\r\n    table: [...],\r\n    defaultActions: {...},\r\n    parseError: function(str, hash),\r\n    parse: function(input),\r\n\r\n    lexer: {\r\n        EOF: 1,\r\n        parseError: function(str, hash),\r\n        setInput: function(input),\r\n        input: function(),\r\n        unput: function(str),\r\n        more: function(),\r\n        less: function(n),\r\n        pastInput: function(),\r\n        upcomingInput: function(),\r\n        showPosition: function(),\r\n        test_match: function(regex_match_array, rule_index),\r\n        next: function(),\r\n        lex: function(),\r\n        begin: function(condition),\r\n        popState: function(),\r\n        _currentRules: function(),\r\n        topState: function(),\r\n        pushState: function(condition),\r\n\r\n        options: {\r\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\r\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\r\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\r\n        },\r\n\r\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\r\n        rules: [...],\r\n        conditions: {associative list: name ==> set},\r\n    }\r\n  }\r\n\r\n\r\n  token location info (@$, _$, etc.): {\r\n    first_line: n,\r\n    last_line: n,\r\n    first_column: n,\r\n    last_column: n,\r\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\r\n  }\r\n\r\n\r\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\r\n    text:        (matched text)\r\n    token:       (the produced terminal token, if any)\r\n    line:        (yylineno)\r\n  }\r\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\r\n    loc:         (yylloc)\r\n    expected:    (string describing the set of expected tokens)\r\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\r\n  }\r\n*/\r\nvar xmlA = (function () {\r\n    var o = function (k, v, o, l) { for (o = o || {}, l = k.length; l--; o[k[l]] = v)\r\n        ; return o; }, $V0 = [1, 8], $V1 = [1, 9], $V2 = [1, 15], $V3 = [2, 6, 12, 16], $V4 = [1, 19], $V5 = [14, 18, 20, 22], $V6 = [2, 10, 12, 16], $V7 = [2, 12];\r\n    var parser = { trace: function trace() { },\r\n        yy: {},\r\n        symbols_: { \"error\": 2, \"XML\": 3, \"TAG_CONFIGURACION\": 4, \"LISTA_ETIQUETAS\": 5, \"EOF\": 6, \"ETIQUETA\": 7, \"TAG_APERTURA\": 8, \"TAG_CIERRE\": 9, \"CadenaValores\": 10, \"TAG_UNICO\": 11, \"AbreTagApertura\": 12, \"DELIMITADOR\": 13, \"CierreTagApertura\": 14, \"LISTA_ATRIBUTOS\": 15, \"AbreTagCierre\": 16, \"CierreTagCierre\": 17, \"CierreTagUnico\": 18, \"AbreTagConf\": 19, \"CierreTagConf\": 20, \"ATRIBUTO\": 21, \"NombreAtributo\": 22, \"IgualAtributo\": 23, \"ValorAtributo\": 24, \"$accept\": 0, \"$end\": 1 },\r\n        terminals_: { 2: \"error\", 6: \"EOF\", 10: \"CadenaValores\", 12: \"AbreTagApertura\", 14: \"CierreTagApertura\", 16: \"AbreTagCierre\", 17: \"CierreTagCierre\", 18: \"CierreTagUnico\", 19: \"AbreTagConf\", 20: \"CierreTagConf\", 22: \"NombreAtributo\", 23: \"IgualAtributo\", 24: \"ValorAtributo\" },\r\n        productions_: [0, [3, 3], [3, 2], [5, 2], [5, 1], [7, 3], [7, 3], [7, 2], [7, 1], [7, 2], [13, 1], [13, 1], [8, 3], [8, 2], [9, 2], [11, 3], [11, 2], [4, 3], [15, 2], [15, 1], [21, 3]],\r\n        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\r\n            /* this == yyval */\r\n            var $0 = $$.length - 1;\r\n            switch (yystate) {\r\n                case 1:\r\n                    this.$ = new XmlResultado($$[$0 - 2], $$[$0 - 1]);\r\n                    return this.$;\r\n                    new ReporteGramatica(\"XML -> TAG_CONFIGURACION LISTA_ETIQUETAS EOF\", \"XML.val = TAG_CONFIGURACION.val+LISTA_ETIQUETAS.val\");\r\n                    break;\r\n                case 2:\r\n                    this.$ = new XmlResultado(null, $$[$0]);\r\n                    return this.$;\r\n                    new ReporteGramatica(\"XML -> N LISTA_ETIQUETAS EOF\", \"XML.val = LISTA_ETIQUETAS.val\");\r\n                    break;\r\n                case 3:\r\n                    $$[$0 - 1].push($$[$0]);\r\n                    this.$ = $$[$0 - 1];\r\n                    new ReporteGramatica(\"LISTA_ETIQUETAS -> LISTA_ETIQUETAS  ETIQUETA \", \" LISTA_ETIQUETAS = new Array (Etiquetas)              ----    LISTA_ETIQUETAS.push(ETIQUETA.val)\");\r\n                    break;\r\n                case 4:\r\n                    this.$ = [$$[$0]];\r\n                    new ReporteGramatica(\"LISTA_ETIQUETAS ->  ETIQUETA \", \"LISTA_ETIQUETAS.val =[ETIQUETA.val[\");\r\n                    break;\r\n                case 5:\r\n                    this.$ = new EtiquetaDoble($$[$0 - 2].nombreTagApertura, $$[$0], $$[$0 - 2].listaAtributos, '', $$[$0 - 1], _$[$0 - 2].first_line, _$[$0 - 2].first_column, getId());\r\n                    new ReporteGramatica(\"ETIQUETA -> TAG_APERTURA LISTA_ETIQUETAS TAG_CIERRE \", \"ETIQUETA.val = new ETITQUETA_DOBLE (TAG_APERTURA.val,LISTA_ETIQUETAS.val,TAG_CIERRE.val)\");\r\n                    break;\r\n                case 6:\r\n                    this.$ = new EtiquetaDoble($$[$0 - 2].nombreTagApertura, $$[$0], $$[$0 - 2].listaAtributos, $$[$0 - 1], [], _$[$0 - 2].first_line, _$[$0 - 2].first_column, getId());\r\n                    new ReporteGramatica(\"ETIQUETA -> TAG_APERTURA CadenaValores TAG_CIERRE \", \"ETIQUETA.val = new ETITQUETA_DOBLE (TAG_APERTURA.val,CadenaValores.lexval,TAG_CIERRE.val)\");\r\n                    break;\r\n                case 7:\r\n                    this.$ = new EtiquetaDoble($$[$0 - 1].nombreTagApertura, $$[$0], $$[$0 - 1].listaAtributos, '', [], _$[$0 - 1].first_line, _$[$0 - 1].first_column, getId());\r\n                    new ReporteGramatica(\"ETIQUETA -> TAG_APERTURA  TAG_CIERRE \", \"ETIQUETA.val = new ETITQUETA_DOBLE (TAG_APERTURA.val,[],TAG_CIERRE.val)\");\r\n                    break;\r\n                case 8:\r\n                    this.$ = $$[$0];\r\n                    new ReporteGramatica(\"ETIQUETA -> TAG_UNICO \", \"ETIQUETA.val =TAG_UNICO.val\");\r\n                    break;\r\n                case 9:\r\n                    this.$ = listaError.push(new ControlError(yytext, TipoSeleccion.ERROR_SINTACTICO, this._$.first_line, this._$.first_column, \"XPathAscendente\"));\r\n                    break;\r\n                case 10:\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 11:\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 12:\r\n                    new ReporteGramatica(\"TAG_APERTURA -> AbreTagApertura LISTA_ATRIBUTOS CierreTagApertura \", \"TAG_APERTURA.val =AbreTagApertura.lexval + LISTA_ATRIBUTOS.val + CierreTagApertura.lexval   \");\r\n                    this.$ = {\r\n                        nombreTagApertura: formatTagName($$[$0 - 2]),\r\n                        listaAtributos: $$[$0 - 1]\r\n                    };\r\n                    break;\r\n                case 13:\r\n                    new ReporteGramatica(\"TAG_APERTURA ->AbreTagApertura CierreTagApertura \", \"TAG_APERTURA.val =AbreTagApertura.lexval  + CierreTagApertura.lexval \");\r\n                    this.$ = {\r\n                        nombreTagApertura: formatTagName($$[$0 - 1]),\r\n                        listaAtributos: []\r\n                    };\r\n                    break;\r\n                case 14:\r\n                    this.$ = formatTagName(formatTagName($$[$0 - 1]));\r\n                    new ReporteGramatica(\"TAG_CIERRE ->AbreTagApertura CierreTagApertura \", \"TAG_CIERRE.val =AbreTagApertura.lexval  + CierreTagApertura.lexval \");\r\n                    break;\r\n                case 15:\r\n                    this.$ = new EtiquetaSimple(formatTagName($$[$0 - 2]), $$[$0 - 1], _$[$0 - 2].first_line, _$[$0 - 2].first_column, getId());\r\n                    new ReporteGramatica(\"TAG_UNICO -> AbreTagApertura LISTA_ATRIBUTOS CierreTagUnico \", \"TAG_UNICO.val =new EtiquetaSimple(AbreTagApertura.lexval,LISTA_ATRIBUTOS.val  , CierreTagApertura.lexval) \");\r\n                    break;\r\n                case 16:\r\n                    this.$ = new EtiquetaSimple(formatTagName($$[$0 - 1]), [], _$[$0 - 1].first_line, _$[$0 - 1].first_column, getId());\r\n                    new ReporteGramatica(\"TAG_UNICO ->AbreTagApertura CierreTagApertura \", \"TAG_UNICO.val =new EtiquetaSimple(AbreTagApertura.lexval,[ ]  , CierreTagApertura.lexval) \");\r\n                    break;\r\n                case 17:\r\n                    this.$ = new EtiquetaInicio($$[$0 - 1], _$[$0 - 2].first_line, _$[$0 - 2].first_column, getId());\r\n                    new ReporteGramatica(\"TAG_CONFIGURACION ->AbreTagConf LISTA_ATRIBUTOS CierreTagConf\", \"TAG_CONFIGURACION.val =new EtiquetaInicio(AbreTagConf.lexval,LISTA_ATRIBUTOS.val  , CierreTagConf.lexval) \");\r\n                    break;\r\n                case 18:\r\n                    $$[$0 - 1].push($$[$0]);\r\n                    this.$ = $$[$0 - 1];\r\n                    new ReporteGramatica(\"LISTA_ATRIBUTOS -> LISTA_ATRIBUTOS  ATRIBUTO \", \" LISTA_ATRIBUTO= new Array () ----- LISTA_ATRIBUTO.push(ATRIBUTO.val)\");\r\n                    break;\r\n                case 19:\r\n                    this.$ = [$$[$0]];\r\n                    new ReporteGramatica(\"LISTA_ATRIBUTO -> ATRIBUTO \", \"LISTA_ATRIBUTO.=[ATRIBUTO.val]\");\r\n                    break;\r\n                case 20:\r\n                    new ReporteGramatica(\"ATRIBUTO -> NombreAtributo IgualAtributo ValorAtributo  \", \"ATRIBUTO.val=new Atributo (NombreAtributo.lexval,IgualAtributo.lexval,ValorAtributo.lexval)\");\r\n                    this.$ = new Atributo($$[$0 - 2], $$[$0], _$[$0 - 2].first_line, _$[$0 - 2].first_column, getId());\r\n                    break;\r\n            }\r\n        },\r\n        table: [{ 2: $V0, 3: 1, 4: 2, 5: 3, 7: 5, 8: 6, 11: 7, 12: $V1, 19: [1, 4] }, { 1: [3] }, { 2: $V0, 5: 10, 7: 5, 8: 6, 11: 7, 12: $V1 }, { 2: $V0, 6: [1, 11], 7: 12, 8: 6, 11: 7, 12: $V1 }, { 15: 13, 21: 14, 22: $V2 }, o($V3, [2, 4]), { 2: $V0, 5: 16, 7: 5, 8: 6, 9: 18, 10: [1, 17], 11: 7, 12: $V1, 16: $V4 }, o($V3, [2, 8]), { 12: [1, 20] }, { 14: [1, 22], 15: 21, 18: [1, 23], 21: 14, 22: $V2 }, { 2: $V0, 6: [1, 24], 7: 12, 8: 6, 11: 7, 12: $V1 }, { 1: [2, 2] }, o($V3, [2, 3]), { 20: [1, 25], 21: 26, 22: $V2 }, o($V5, [2, 19]), { 23: [1, 27] }, { 2: $V0, 7: 12, 8: 6, 9: 28, 11: 7, 12: $V1, 16: $V4 }, { 9: 29, 16: $V4 }, o($V3, [2, 7]), { 17: [1, 30] }, o($V3, [2, 9]), { 14: [1, 31], 18: [1, 32], 21: 26, 22: $V2 }, o($V6, [2, 13]), o($V3, [2, 16]), { 1: [2, 1] }, o($V7, [2, 17]), o($V5, [2, 18]), { 24: [1, 33] }, o($V3, [2, 5]), o($V3, [2, 6]), o($V3, [2, 14]), o($V6, $V7), o($V3, [2, 15]), o($V5, [2, 20])],\r\n        defaultActions: { 11: [2, 2], 24: [2, 1] },\r\n        parseError: function parseError(str, hash) {\r\n            if (hash.recoverable) {\r\n                this.trace(str);\r\n            }\r\n            else {\r\n                var error = new Error(str);\r\n                error.hash = hash;\r\n                throw error;\r\n            }\r\n        },\r\n        parse: function parse(input) {\r\n            var self = this, stack = [0], tstack = [], // token stack\r\n            vstack = [null], // semantic value stack\r\n            lstack = [], // location stack\r\n            table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\r\n            var args = lstack.slice.call(arguments, 1);\r\n            //this.reductionCount = this.shiftCount = 0;\r\n            var lexer = Object.create(this.lexer);\r\n            var sharedState = { yy: {} };\r\n            // copy state\r\n            for (var k in this.yy) {\r\n                if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\r\n                    sharedState.yy[k] = this.yy[k];\r\n                }\r\n            }\r\n            lexer.setInput(input, sharedState.yy);\r\n            sharedState.yy.lexer = lexer;\r\n            sharedState.yy.parser = this;\r\n            if (typeof lexer.yylloc == 'undefined') {\r\n                lexer.yylloc = {};\r\n            }\r\n            var yyloc = lexer.yylloc;\r\n            lstack.push(yyloc);\r\n            var ranges = lexer.options && lexer.options.ranges;\r\n            if (typeof sharedState.yy.parseError === 'function') {\r\n                this.parseError = sharedState.yy.parseError;\r\n            }\r\n            else {\r\n                this.parseError = Object.getPrototypeOf(this).parseError;\r\n            }\r\n            function popStack(n) {\r\n                stack.length = stack.length - 2 * n;\r\n                vstack.length = vstack.length - n;\r\n                lstack.length = lstack.length - n;\r\n            }\r\n            _token_stack: var lex = function () {\r\n                var token;\r\n                token = lexer.lex() || EOF;\r\n                // if token isn't its numeric value, convert\r\n                if (typeof token !== 'number') {\r\n                    token = self.symbols_[token] || token;\r\n                }\r\n                return token;\r\n            };\r\n            var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\r\n            while (true) {\r\n                // retreive state number from top of stack\r\n                state = stack[stack.length - 1];\r\n                // use default actions if available\r\n                if (this.defaultActions[state]) {\r\n                    action = this.defaultActions[state];\r\n                }\r\n                else {\r\n                    if (symbol === null || typeof symbol == 'undefined') {\r\n                        symbol = lex();\r\n                    }\r\n                    // read action for current state and first input\r\n                    action = table[state] && table[state][symbol];\r\n                }\r\n                _handle_error: \r\n                // handle parse error\r\n                if (typeof action === 'undefined' || !action.length || !action[0]) {\r\n                    var error_rule_depth;\r\n                    var errStr = '';\r\n                    // Return the rule stack depth where the nearest error rule can be found.\r\n                    // Return FALSE when no error recovery rule was found.\r\n                    function locateNearestErrorRecoveryRule(state) {\r\n                        var stack_probe = stack.length - 1;\r\n                        var depth = 0;\r\n                        // try to recover from error\r\n                        for (;;) {\r\n                            // check for error recovery rule in this state\r\n                            if ((TERROR.toString()) in table[state]) {\r\n                                return depth;\r\n                            }\r\n                            if (state === 0 || stack_probe < 2) {\r\n                                return false; // No suitable error recovery rule available.\r\n                            }\r\n                            stack_probe -= 2; // popStack(1): [symbol, action]\r\n                            state = stack[stack_probe];\r\n                            ++depth;\r\n                        }\r\n                    }\r\n                    if (!recovering) {\r\n                        // first see if there's any chance at hitting an error recovery rule:\r\n                        error_rule_depth = locateNearestErrorRecoveryRule(state);\r\n                        // Report error\r\n                        expected = [];\r\n                        for (p in table[state]) {\r\n                            if (this.terminals_[p] && p > TERROR) {\r\n                                expected.push(\"'\" + this.terminals_[p] + \"'\");\r\n                            }\r\n                        }\r\n                        if (lexer.showPosition) {\r\n                            errStr = 'Parse error on line ' + (yylineno + 1) + \":\\n\" + lexer.showPosition() + \"\\nExpecting \" + expected.join(', ') + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\r\n                        }\r\n                        else {\r\n                            errStr = 'Parse error on line ' + (yylineno + 1) + \": Unexpected \" +\r\n                                (symbol == EOF ? \"end of input\" :\r\n                                    (\"'\" + (this.terminals_[symbol] || symbol) + \"'\"));\r\n                        }\r\n                        this.parseError(errStr, {\r\n                            text: lexer.match,\r\n                            token: this.terminals_[symbol] || symbol,\r\n                            line: lexer.yylineno,\r\n                            loc: yyloc,\r\n                            expected: expected,\r\n                            recoverable: (error_rule_depth !== false)\r\n                        });\r\n                    }\r\n                    else if (preErrorSymbol !== EOF) {\r\n                        error_rule_depth = locateNearestErrorRecoveryRule(state);\r\n                    }\r\n                    // just recovered from another error\r\n                    if (recovering == 3) {\r\n                        if (symbol === EOF || preErrorSymbol === EOF) {\r\n                            throw new Error(errStr || 'Parsing halted while starting to recover from another error.');\r\n                        }\r\n                        // discard current lookahead and grab another\r\n                        yyleng = lexer.yyleng;\r\n                        yytext = lexer.yytext;\r\n                        yylineno = lexer.yylineno;\r\n                        yyloc = lexer.yylloc;\r\n                        symbol = lex();\r\n                    }\r\n                    // try to recover from error\r\n                    if (error_rule_depth === false) {\r\n                        throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');\r\n                    }\r\n                    popStack(error_rule_depth);\r\n                    preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token\r\n                    symbol = TERROR; // insert generic error symbol as new lookahead\r\n                    state = stack[stack.length - 1];\r\n                    action = table[state] && table[state][TERROR];\r\n                    recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\r\n                }\r\n                // this shouldn't happen, unless resolve defaults are off\r\n                if (action[0] instanceof Array && action.length > 1) {\r\n                    throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\r\n                }\r\n                switch (action[0]) {\r\n                    case 1: // shift\r\n                        //this.shiftCount++;\r\n                        stack.push(symbol);\r\n                        vstack.push(lexer.yytext);\r\n                        lstack.push(lexer.yylloc);\r\n                        stack.push(action[1]); // push state\r\n                        symbol = null;\r\n                        if (!preErrorSymbol) { // normal execution/no error\r\n                            yyleng = lexer.yyleng;\r\n                            yytext = lexer.yytext;\r\n                            yylineno = lexer.yylineno;\r\n                            yyloc = lexer.yylloc;\r\n                            if (recovering > 0) {\r\n                                recovering--;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // error just occurred, resume old lookahead f/ before error\r\n                            symbol = preErrorSymbol;\r\n                            preErrorSymbol = null;\r\n                        }\r\n                        break;\r\n                    case 2:\r\n                        // reduce\r\n                        //this.reductionCount++;\r\n                        len = this.productions_[action[1]][1];\r\n                        // perform semantic action\r\n                        yyval.$ = vstack[vstack.length - len]; // default to $$ = $1\r\n                        // default location, uses first token for firsts, last for lasts\r\n                        yyval._$ = {\r\n                            first_line: lstack[lstack.length - (len || 1)].first_line,\r\n                            last_line: lstack[lstack.length - 1].last_line,\r\n                            first_column: lstack[lstack.length - (len || 1)].first_column,\r\n                            last_column: lstack[lstack.length - 1].last_column\r\n                        };\r\n                        if (ranges) {\r\n                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];\r\n                        }\r\n                        r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));\r\n                        if (typeof r !== 'undefined') {\r\n                            return r;\r\n                        }\r\n                        // pop off stack\r\n                        if (len) {\r\n                            stack = stack.slice(0, -1 * len * 2);\r\n                            vstack = vstack.slice(0, -1 * len);\r\n                            lstack = lstack.slice(0, -1 * len);\r\n                        }\r\n                        stack.push(this.productions_[action[1]][0]); // push nonterminal (reduce)\r\n                        vstack.push(yyval.$);\r\n                        lstack.push(yyval._$);\r\n                        // goto new state = table[STATE][NONTERMINAL]\r\n                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\r\n                        stack.push(newState);\r\n                        break;\r\n                    case 3:\r\n                        // accept\r\n                        return true;\r\n                }\r\n            }\r\n            return true;\r\n        } };\r\n    const { EtiquetaDoble } = require('../Xml/EtiquetaDoble');\r\n    const { EtiquetaSimple } = require('../Xml/EtiquetaSimple');\r\n    const { EtiquetaInicio } = require('../Xml/EtiquetaInicio');\r\n    const { Atributo } = require('../Xml/Atributo');\r\n    const { XmlResultado } = require('../Xml/XmlResultado');\r\n    const { ControlError } = require('../Xpath/ControlError');\r\n    const { TipoSeleccion } = require('../Xpath/TipoSeleccion');\r\n    const { ReporteGramatica } = require('../Reportes/ReporteGramatica');\r\n    let idSent = 1;\r\n    function getId() {\r\n        idSent += 100;\r\n        return idSent;\r\n    }\r\n    function formatTagName(AbreTagApertura) {\r\n        return AbreTagApertura.substring(1, AbreTagApertura.length);\r\n    }\r\n    /* generated by jison-lex 0.3.4 */\r\n    var lexer = (function () {\r\n        var lexer = ({\r\n            EOF: 1,\r\n            parseError: function parseError(str, hash) {\r\n                if (this.yy.parser) {\r\n                    this.yy.parser.parseError(str, hash);\r\n                }\r\n                else {\r\n                    throw new Error(str);\r\n                }\r\n            },\r\n            // resets the lexer, sets new input\r\n            setInput: function (input, yy) {\r\n                this.yy = yy || this.yy || {};\r\n                this._input = input;\r\n                this._more = this._backtrack = this.done = false;\r\n                this.yylineno = this.yyleng = 0;\r\n                this.yytext = this.matched = this.match = '';\r\n                this.conditionStack = ['INITIAL'];\r\n                this.yylloc = {\r\n                    first_line: 1,\r\n                    first_column: 0,\r\n                    last_line: 1,\r\n                    last_column: 0\r\n                };\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [0, 0];\r\n                }\r\n                this.offset = 0;\r\n                return this;\r\n            },\r\n            // consumes and returns one char from the input\r\n            input: function () {\r\n                var ch = this._input[0];\r\n                this.yytext += ch;\r\n                this.yyleng++;\r\n                this.offset++;\r\n                this.match += ch;\r\n                this.matched += ch;\r\n                var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\r\n                if (lines) {\r\n                    this.yylineno++;\r\n                    this.yylloc.last_line++;\r\n                }\r\n                else {\r\n                    this.yylloc.last_column++;\r\n                }\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range[1]++;\r\n                }\r\n                this._input = this._input.slice(1);\r\n                return ch;\r\n            },\r\n            // unshifts one char (or a string) into the input\r\n            unput: function (ch) {\r\n                var len = ch.length;\r\n                var lines = ch.split(/(?:\\r\\n?|\\n)/g);\r\n                this._input = ch + this._input;\r\n                this.yytext = this.yytext.substr(0, this.yytext.length - len);\r\n                //this.yyleng -= len;\r\n                this.offset -= len;\r\n                var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\r\n                this.match = this.match.substr(0, this.match.length - 1);\r\n                this.matched = this.matched.substr(0, this.matched.length - 1);\r\n                if (lines.length - 1) {\r\n                    this.yylineno -= lines.length - 1;\r\n                }\r\n                var r = this.yylloc.range;\r\n                this.yylloc = {\r\n                    first_line: this.yylloc.first_line,\r\n                    last_line: this.yylineno + 1,\r\n                    first_column: this.yylloc.first_column,\r\n                    last_column: lines ?\r\n                        (lines.length === oldLines.length ? this.yylloc.first_column : 0)\r\n                            + oldLines[oldLines.length - lines.length].length - lines[0].length :\r\n                        this.yylloc.first_column - len\r\n                };\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];\r\n                }\r\n                this.yyleng = this.yytext.length;\r\n                return this;\r\n            },\r\n            // When called from action, caches matched text and appends it on next action\r\n            more: function () {\r\n                this._more = true;\r\n                return this;\r\n            },\r\n            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\r\n            reject: function () {\r\n                if (this.options.backtrack_lexer) {\r\n                    this._backtrack = true;\r\n                }\r\n                else {\r\n                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\r\n                        text: \"\",\r\n                        token: null,\r\n                        line: this.yylineno\r\n                    });\r\n                }\r\n                return this;\r\n            },\r\n            // retain first n characters of the match\r\n            less: function (n) {\r\n                this.unput(this.match.slice(n));\r\n            },\r\n            // displays already matched input, i.e. for error messages\r\n            pastInput: function () {\r\n                var past = this.matched.substr(0, this.matched.length - this.match.length);\r\n                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\\n/g, \"\");\r\n            },\r\n            // displays upcoming input, i.e. for error messages\r\n            upcomingInput: function () {\r\n                var next = this.match;\r\n                if (next.length < 20) {\r\n                    next += this._input.substr(0, 20 - next.length);\r\n                }\r\n                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\r\n            },\r\n            // displays the character position where the lexing error occurred, i.e. for error messages\r\n            showPosition: function () {\r\n                var pre = this.pastInput();\r\n                var c = new Array(pre.length + 1).join(\"-\");\r\n                return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\r\n            },\r\n            // test the lexed token: return FALSE when not a match, otherwise return token\r\n            test_match: function (match, indexed_rule) {\r\n                var token, lines, backup;\r\n                if (this.options.backtrack_lexer) {\r\n                    // save context\r\n                    backup = {\r\n                        yylineno: this.yylineno,\r\n                        yylloc: {\r\n                            first_line: this.yylloc.first_line,\r\n                            last_line: this.last_line,\r\n                            first_column: this.yylloc.first_column,\r\n                            last_column: this.yylloc.last_column\r\n                        },\r\n                        yytext: this.yytext,\r\n                        match: this.match,\r\n                        matches: this.matches,\r\n                        matched: this.matched,\r\n                        yyleng: this.yyleng,\r\n                        offset: this.offset,\r\n                        _more: this._more,\r\n                        _input: this._input,\r\n                        yy: this.yy,\r\n                        conditionStack: this.conditionStack.slice(0),\r\n                        done: this.done\r\n                    };\r\n                    if (this.options.ranges) {\r\n                        backup.yylloc.range = this.yylloc.range.slice(0);\r\n                    }\r\n                }\r\n                lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\r\n                if (lines) {\r\n                    this.yylineno += lines.length;\r\n                }\r\n                this.yylloc = {\r\n                    first_line: this.yylloc.last_line,\r\n                    last_line: this.yylineno + 1,\r\n                    first_column: this.yylloc.last_column,\r\n                    last_column: lines ?\r\n                        lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\r\n                        this.yylloc.last_column + match[0].length\r\n                };\r\n                this.yytext += match[0];\r\n                this.match += match[0];\r\n                this.matches = match;\r\n                this.yyleng = this.yytext.length;\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [this.offset, this.offset += this.yyleng];\r\n                }\r\n                this._more = false;\r\n                this._backtrack = false;\r\n                this._input = this._input.slice(match[0].length);\r\n                this.matched += match[0];\r\n                token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\r\n                if (this.done && this._input) {\r\n                    this.done = false;\r\n                }\r\n                if (token) {\r\n                    return token;\r\n                }\r\n                else if (this._backtrack) {\r\n                    // recover context\r\n                    for (var k in backup) {\r\n                        this[k] = backup[k];\r\n                    }\r\n                    return false; // rule action called reject() implying the next rule should be tested instead.\r\n                }\r\n                return false;\r\n            },\r\n            // return next match in input\r\n            next: function () {\r\n                if (this.done) {\r\n                    return this.EOF;\r\n                }\r\n                if (!this._input) {\r\n                    this.done = true;\r\n                }\r\n                var token, match, tempMatch, index;\r\n                if (!this._more) {\r\n                    this.yytext = '';\r\n                    this.match = '';\r\n                }\r\n                var rules = this._currentRules();\r\n                for (var i = 0; i < rules.length; i++) {\r\n                    tempMatch = this._input.match(this.rules[rules[i]]);\r\n                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\r\n                        match = tempMatch;\r\n                        index = i;\r\n                        if (this.options.backtrack_lexer) {\r\n                            token = this.test_match(tempMatch, rules[i]);\r\n                            if (token !== false) {\r\n                                return token;\r\n                            }\r\n                            else if (this._backtrack) {\r\n                                match = false;\r\n                                continue; // rule action called reject() implying a rule MISmatch.\r\n                            }\r\n                            else {\r\n                                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n                                return false;\r\n                            }\r\n                        }\r\n                        else if (!this.options.flex) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (match) {\r\n                    token = this.test_match(match, rules[index]);\r\n                    if (token !== false) {\r\n                        return token;\r\n                    }\r\n                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n                    return false;\r\n                }\r\n                if (this._input === \"\") {\r\n                    return this.EOF;\r\n                }\r\n                else {\r\n                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\r\n                        text: \"\",\r\n                        token: null,\r\n                        line: this.yylineno\r\n                    });\r\n                }\r\n            },\r\n            // return next match that has a token\r\n            lex: function lex() {\r\n                var r = this.next();\r\n                if (r) {\r\n                    return r;\r\n                }\r\n                else {\r\n                    return this.lex();\r\n                }\r\n            },\r\n            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\r\n            begin: function begin(condition) {\r\n                this.conditionStack.push(condition);\r\n            },\r\n            // pop the previously active lexer condition state off the condition stack\r\n            popState: function popState() {\r\n                var n = this.conditionStack.length - 1;\r\n                if (n > 0) {\r\n                    return this.conditionStack.pop();\r\n                }\r\n                else {\r\n                    return this.conditionStack[0];\r\n                }\r\n            },\r\n            // produce the lexer rule set which is active for the currently active lexer condition state\r\n            _currentRules: function _currentRules() {\r\n                if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\r\n                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\r\n                }\r\n                else {\r\n                    return this.conditions[\"INITIAL\"].rules;\r\n                }\r\n            },\r\n            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\r\n            topState: function topState(n) {\r\n                n = this.conditionStack.length - 1 - Math.abs(n || 0);\r\n                if (n >= 0) {\r\n                    return this.conditionStack[n];\r\n                }\r\n                else {\r\n                    return \"INITIAL\";\r\n                }\r\n            },\r\n            // alias for begin(condition)\r\n            pushState: function pushState(condition) {\r\n                this.begin(condition);\r\n            },\r\n            // return the number of states currently on the stack\r\n            stateStackSize: function stateStackSize() {\r\n                return this.conditionStack.length;\r\n            },\r\n            options: { \"case-insensitive\": true },\r\n            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\r\n                var YYSTATE = YY_START;\r\n                switch ($avoiding_name_collisions) {\r\n                    case 0:\r\n                        this.begin(\"Comentario\");\r\n                        break;\r\n                    case 1:\r\n                        break;\r\n                    case 2:\r\n                        break;\r\n                    case 3:\r\n                        this.popState();\r\n                        break;\r\n                    case 4:\r\n                        break;\r\n                    case 5:\r\n                        this.begin(\"TagApertura\");\r\n                        return 19;\r\n                        break;\r\n                    case 6:\r\n                        break;\r\n                    case 7:\r\n                        return 22;\r\n                        break;\r\n                    case 8:\r\n                        return 23;\r\n                        break;\r\n                    case 9:\r\n                        return 24;\r\n                        break;\r\n                    case 10:\r\n                        this.popState();\r\n                        return 20;\r\n                        break;\r\n                    case 11:\r\n                        this.begin(\"TagApertura\");\r\n                        return 12;\r\n                        break;\r\n                    case 12:\r\n                        break;\r\n                    case 13:\r\n                        return 22;\r\n                        break;\r\n                    case 14:\r\n                        return 23;\r\n                        break;\r\n                    case 15:\r\n                        return 24;\r\n                        break;\r\n                    case 16:\r\n                        this.popState();\r\n                        return 14;\r\n                        break;\r\n                    case 17:\r\n                        this.popState();\r\n                        return 18;\r\n                        break;\r\n                    case 18:\r\n                        this.begin(\"TagCierre\");\r\n                        return 16;\r\n                        break;\r\n                    case 19:\r\n                        this.popState();\r\n                        return 17;\r\n                        break;\r\n                    case 20:\r\n                        break;\r\n                    case 21:\r\n                        return 10;\r\n                        break;\r\n                    case 22:\r\n                        return 6;\r\n                        break;\r\n                    case 23:\r\n                        $$ = listaError.push(new ControlError(yy_.yytext, TipoSeleccion.ERROR_SINTACTICO, this._$.first_line, this._$.first_column, \"XPathAscendente\"));\r\n                        break;\r\n                }\r\n            },\r\n            rules: [/^(?:<!--)/i, /^(?:[\\r\\t]+)/i, /^(?:\\n)/i, /^(?:-->)/i, /^(?:[^\"-->\"]+)/i, /^(?:<\\?xml\\b)/i, /^(?:[\\s\\r\\t\\n]+)/i, /^(?:[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:=)/i, /^(?:\"[^\\\"\\n]*\")/i, /^(?:\\?>)/i, /^(?:<[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:[\\s\\r\\t\\n]+)/i, /^(?:[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:=)/i, /^(?:\"[^\\\"\\n]*\")/i, /^(?:>)/i, /^(?:\\/>)/i, /^(?:<\\/[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:>)/i, /^(?:[\\s\\r\\t\\n]+)/i, /^(?:[^<]+)/i, /^(?:$)/i, /^(?:.)/i],\r\n            conditions: { \"TagCierre\": { \"rules\": [19], \"inclusive\": false }, \"TagApertura\": { \"rules\": [6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17], \"inclusive\": false }, \"Comentario\": { \"rules\": [1, 2, 3, 4], \"inclusive\": false }, \"INITIAL\": { \"rules\": [0, 5, 11, 18, 20, 21, 22, 23], \"inclusive\": true } }\r\n        });\r\n        return lexer;\r\n    })();\r\n    parser.lexer = lexer;\r\n    function Parser() {\r\n        this.yy = {};\r\n    }\r\n    Parser.prototype = parser;\r\n    parser.Parser = Parser;\r\n    return new Parser;\r\n})();\r\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\r\n    exports.parser = xmlA;\r\n    exports.Parser = xmlA.Parser;\r\n    exports.parse = function () { return xmlA.parse.apply(xmlA, arguments); };\r\n    exports.main = function commonjsMain(args) {\r\n        if (!args[1]) {\r\n            console.log('Usage: ' + args[0] + ' FILE');\r\n            process.exit(1);\r\n        }\r\n        var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\r\n        return exports.parser.parse(source);\r\n    };\r\n    if (typeof module !== 'undefined' && require.main === module) {\r\n        exports.main(process.argv.slice(1));\r\n    }\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TipoSeleccion;\r\n(function (TipoSeleccion) {\r\n    TipoSeleccion[\"ACCESO_NODO_RAIZ\"] = \"ACCESO_NODO_RAIZ\";\r\n    TipoSeleccion[\"SELECT_NODOS_FROM_NODO\"] = \"SELECT_NODOS_FROM_NODO\";\r\n    TipoSeleccion[\"ERROR_SINTACTICO\"] = \"ERROR_SINTACTICO\";\r\n    TipoSeleccion[\"ERROR_LEXICO\"] = \"ERROR_LEXICO\";\r\n    TipoSeleccion[\"ERROR_SEMANTICO\"] = \"ERROR_SEMANTICO\";\r\n})(TipoSeleccion = exports.TipoSeleccion || (exports.TipoSeleccion = {}));\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Tipos;\r\n(function (Tipos) {\r\n    Tipos[\"ETIQUETA_DOBLE\"] = \"ETIQUETA_DOBLE\";\r\n    Tipos[\"ETIQUETA_SIMPLE\"] = \"ETIQUETA_SIMPLE\";\r\n    Tipos[\"ETIQUETA_UNICA\"] = \"ETIQUETA_UNICA\";\r\n    Tipos[\"ATRIBUTO\"] = \"ATRIBUTO\";\r\n    Tipos[\"VALOR\"] = \"VALOR\";\r\n})(Tipos = exports.Tipos || (exports.Tipos = {}));\r\n","/* parser generated by jison 0.4.18 */\r\n/*\r\n  Returns a Parser object of the following structure:\r\n\r\n  Parser: {\r\n    yy: {}\r\n  }\r\n\r\n  Parser.prototype: {\r\n    yy: {},\r\n    trace: function(),\r\n    symbols_: {associative list: name ==> number},\r\n    terminals_: {associative list: number ==> name},\r\n    productions_: [...],\r\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\r\n    table: [...],\r\n    defaultActions: {...},\r\n    parseError: function(str, hash),\r\n    parse: function(input),\r\n\r\n    lexer: {\r\n        EOF: 1,\r\n        parseError: function(str, hash),\r\n        setInput: function(input),\r\n        input: function(),\r\n        unput: function(str),\r\n        more: function(),\r\n        less: function(n),\r\n        pastInput: function(),\r\n        upcomingInput: function(),\r\n        showPosition: function(),\r\n        test_match: function(regex_match_array, rule_index),\r\n        next: function(),\r\n        lex: function(),\r\n        begin: function(condition),\r\n        popState: function(),\r\n        _currentRules: function(),\r\n        topState: function(),\r\n        pushState: function(condition),\r\n\r\n        options: {\r\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\r\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\r\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\r\n        },\r\n\r\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\r\n        rules: [...],\r\n        conditions: {associative list: name ==> set},\r\n    }\r\n  }\r\n\r\n\r\n  token location info (@$, _$, etc.): {\r\n    first_line: n,\r\n    last_line: n,\r\n    first_column: n,\r\n    last_column: n,\r\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\r\n  }\r\n\r\n\r\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\r\n    text:        (matched text)\r\n    token:       (the produced terminal token, if any)\r\n    line:        (yylineno)\r\n  }\r\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\r\n    loc:         (yylloc)\r\n    expected:    (string describing the set of expected tokens)\r\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\r\n  }\r\n*/\r\nvar xpathA = (function () {\r\n    var o = function (k, v, o, l) { for (o = o || {}, l = k.length; l--; o[k[l]] = v)\r\n        ; return o; }, $V0 = [1, 7], $V1 = [1, 8], $V2 = [1, 9], $V3 = [1, 5], $V4 = [5, 6], $V5 = [2, 5, 6, 10, 11, 12], $V6 = [2, 5, 6, 10, 11, 12, 14, 15, 16, 17], $V7 = [1, 25], $V8 = [1, 26], $V9 = [1, 31], $Va = [1, 30], $Vb = [10, 17, 20, 21, 22], $Vc = [20, 21, 22];\r\n    var parser = { trace: function trace() { },\r\n        yy: {},\r\n        symbols_: { \"error\": 2, \"XPATH\": 3, \"CONCATENACION_SETS\": 4, \"EOF\": 5, \"barraVertical\": 6, \"LISTA_SETS\": 7, \"SET\": 8, \"SELECTOR\": 9, \"slash\": 10, \"dobleSlash\": 11, \"identificador\": 12, \"PREDICADO\": 13, \"arroba\": 14, \"dosPuntos\": 15, \"punto\": 16, \"asterisco\": 17, \"corecheteA\": 18, \"OPERACION\": 19, \"corcheteC\": 20, \"mas\": 21, \"menos\": 22, \"entero\": 23, \"decimal\": 24, \"$accept\": 0, \"$end\": 1 },\r\n        terminals_: { 2: \"error\", 5: \"EOF\", 6: \"barraVertical\", 10: \"slash\", 11: \"dobleSlash\", 12: \"identificador\", 14: \"arroba\", 15: \"dosPuntos\", 16: \"punto\", 17: \"asterisco\", 18: \"corecheteA\", 20: \"corcheteC\", 21: \"mas\", 22: \"menos\", 23: \"entero\", 24: \"decimal\" },\r\n        productions_: [0, [3, 2], [4, 3], [4, 1], [7, 2], [7, 1], [9, 1], [9, 1], [8, 1], [8, 2], [8, 3], [8, 3], [8, 2], [8, 2], [8, 3], [8, 2], [8, 2], [13, 3], [19, 3], [19, 3], [19, 3], [19, 3], [19, 1], [19, 1]],\r\n        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\r\n            /* this == yyval */\r\n            var $0 = $$.length - 1;\r\n            switch (yystate) {\r\n                case 1:\r\n                    return $$[$0 - 1];\r\n                    break;\r\n                case 2:\r\n                    $$[$0 - 2].push($$[$0]);\r\n                    this.$ = $$[$0 - 2];\r\n                    break;\r\n                case 3:\r\n                    this.$ = [$$[$0]];\r\n                    break;\r\n                case 4:\r\n                    aux = $$[$0 - 1];\r\n                    while (aux.next != null) {\r\n                        aux = aux.next;\r\n                    }\r\n                    ;\r\n                    aux.next = $$[$0];\r\n                    this.$ = $$[$0 - 1];\r\n                    break;\r\n                case 5:\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 6:\r\n                case 7:\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 8:\r\n                    this.$ = { tipo: TipoSeleccion.ACCESO_NODO_RAIZ, id: $$[$0], next: null };\r\n                    break;\r\n                case 9:\r\n                    this.$ = { tipo: TipoSeleccion.SELECT_NODOS_FROM_NODO, selector: $$[$0 - 1], id: $$[$0], predicado: null, next: null };\r\n                    break;\r\n                case 10:\r\n                    this.$ = { tipo: TipoSeleccion.SELECT_NODOS_FROM_NODO, selector: $$[$0 - 2], id: $$[$0 - 1], predicado: $$[$0], next: null };\r\n                    break;\r\n                case 16:\r\n                    this.$ = new ControlError(yytext, TipoSeleccion.ERROR_SINTACTICO, this._$.first_line, this._$.first_column, \"XPathAscendente\");\r\n                    break;\r\n                case 17:\r\n                    this.$ = $$[$0 - 1];\r\n                    break;\r\n                case 18:\r\n                    this.$ = new OpBinaria($$[$0 - 2], $$[$0], TiposOp.SUMA);\r\n                    break;\r\n                case 19:\r\n                    this.$ = new OpBinaria($$[$0 - 2], $$[$0], TiposOp.RESTA);\r\n                    break;\r\n                case 20:\r\n                    this.$ = new OpBinaria($$[$0 - 2], $$[$0], TiposOp.MULTIPLICACION);\r\n                    break;\r\n                case 21:\r\n                    this.$ = new OpBinaria($$[$0 - 2], $$[$0], TiposOp.DIVISION);\r\n                    break;\r\n                case 22:\r\n                    this.$ = new Primitivo(parseInt($$[$0]), TipoVal.ENTERO);\r\n                    break;\r\n                case 23:\r\n                    this.$ = new Primitivo(parseFloat($$[$0]), TipoVal.DECIMAL);\r\n                    break;\r\n            }\r\n        },\r\n        table: [{ 2: $V0, 3: 1, 4: 2, 7: 3, 8: 4, 9: 6, 10: $V1, 11: $V2, 12: $V3 }, { 1: [3] }, { 5: [1, 10], 6: [1, 11] }, o($V4, [2, 3], { 9: 6, 8: 12, 2: $V0, 10: $V1, 11: $V2, 12: $V3 }), o($V5, [2, 5]), o($V5, [2, 8]), { 12: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16], 17: [1, 17] }, { 9: 18, 10: $V1, 11: $V2 }, o($V6, [2, 6]), o($V6, [2, 7]), { 1: [2, 1] }, { 2: $V0, 7: 19, 8: 4, 9: 6, 10: $V1, 11: $V2, 12: $V3 }, o($V5, [2, 4]), o($V5, [2, 9], { 13: 20, 18: [1, 21] }), { 12: [1, 22], 17: [1, 23] }, o($V5, [2, 12]), o($V5, [2, 13]), o($V5, [2, 15]), o($V5, [2, 16]), o($V4, [2, 2], { 9: 6, 8: 12, 2: $V0, 10: $V1, 11: $V2, 12: $V3 }), o($V5, [2, 10]), { 19: 24, 23: $V7, 24: $V8 }, o($V5, [2, 11]), o($V5, [2, 14]), { 10: $V9, 17: $Va, 20: [1, 27], 21: [1, 28], 22: [1, 29] }, o($Vb, [2, 22]), o($Vb, [2, 23]), o($V5, [2, 17]), { 19: 32, 23: $V7, 24: $V8 }, { 19: 33, 23: $V7, 24: $V8 }, { 19: 34, 23: $V7, 24: $V8 }, { 19: 35, 23: $V7, 24: $V8 }, o($Vc, [2, 18], { 10: $V9, 17: $Va }), o($Vc, [2, 19], { 10: $V9, 17: $Va }), o($Vb, [2, 20]), o($Vb, [2, 21])],\r\n        defaultActions: { 10: [2, 1] },\r\n        parseError: function parseError(str, hash) {\r\n            if (hash.recoverable) {\r\n                this.trace(str);\r\n            }\r\n            else {\r\n                var error = new Error(str);\r\n                error.hash = hash;\r\n                throw error;\r\n            }\r\n        },\r\n        parse: function parse(input) {\r\n            var self = this, stack = [0], tstack = [], // token stack\r\n            vstack = [null], // semantic value stack\r\n            lstack = [], // location stack\r\n            table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\r\n            var args = lstack.slice.call(arguments, 1);\r\n            //this.reductionCount = this.shiftCount = 0;\r\n            var lexer = Object.create(this.lexer);\r\n            var sharedState = { yy: {} };\r\n            // copy state\r\n            for (var k in this.yy) {\r\n                if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\r\n                    sharedState.yy[k] = this.yy[k];\r\n                }\r\n            }\r\n            lexer.setInput(input, sharedState.yy);\r\n            sharedState.yy.lexer = lexer;\r\n            sharedState.yy.parser = this;\r\n            if (typeof lexer.yylloc == 'undefined') {\r\n                lexer.yylloc = {};\r\n            }\r\n            var yyloc = lexer.yylloc;\r\n            lstack.push(yyloc);\r\n            var ranges = lexer.options && lexer.options.ranges;\r\n            if (typeof sharedState.yy.parseError === 'function') {\r\n                this.parseError = sharedState.yy.parseError;\r\n            }\r\n            else {\r\n                this.parseError = Object.getPrototypeOf(this).parseError;\r\n            }\r\n            function popStack(n) {\r\n                stack.length = stack.length - 2 * n;\r\n                vstack.length = vstack.length - n;\r\n                lstack.length = lstack.length - n;\r\n            }\r\n            _token_stack: var lex = function () {\r\n                var token;\r\n                token = lexer.lex() || EOF;\r\n                // if token isn't its numeric value, convert\r\n                if (typeof token !== 'number') {\r\n                    token = self.symbols_[token] || token;\r\n                }\r\n                return token;\r\n            };\r\n            var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\r\n            while (true) {\r\n                // retreive state number from top of stack\r\n                state = stack[stack.length - 1];\r\n                // use default actions if available\r\n                if (this.defaultActions[state]) {\r\n                    action = this.defaultActions[state];\r\n                }\r\n                else {\r\n                    if (symbol === null || typeof symbol == 'undefined') {\r\n                        symbol = lex();\r\n                    }\r\n                    // read action for current state and first input\r\n                    action = table[state] && table[state][symbol];\r\n                }\r\n                _handle_error: \r\n                // handle parse error\r\n                if (typeof action === 'undefined' || !action.length || !action[0]) {\r\n                    var error_rule_depth;\r\n                    var errStr = '';\r\n                    // Return the rule stack depth where the nearest error rule can be found.\r\n                    // Return FALSE when no error recovery rule was found.\r\n                    function locateNearestErrorRecoveryRule(state) {\r\n                        var stack_probe = stack.length - 1;\r\n                        var depth = 0;\r\n                        // try to recover from error\r\n                        for (;;) {\r\n                            // check for error recovery rule in this state\r\n                            if ((TERROR.toString()) in table[state]) {\r\n                                return depth;\r\n                            }\r\n                            if (state === 0 || stack_probe < 2) {\r\n                                return false; // No suitable error recovery rule available.\r\n                            }\r\n                            stack_probe -= 2; // popStack(1): [symbol, action]\r\n                            state = stack[stack_probe];\r\n                            ++depth;\r\n                        }\r\n                    }\r\n                    if (!recovering) {\r\n                        // first see if there's any chance at hitting an error recovery rule:\r\n                        error_rule_depth = locateNearestErrorRecoveryRule(state);\r\n                        // Report error\r\n                        expected = [];\r\n                        for (p in table[state]) {\r\n                            if (this.terminals_[p] && p > TERROR) {\r\n                                expected.push(\"'\" + this.terminals_[p] + \"'\");\r\n                            }\r\n                        }\r\n                        if (lexer.showPosition) {\r\n                            errStr = 'Parse error on line ' + (yylineno + 1) + \":\\n\" + lexer.showPosition() + \"\\nExpecting \" + expected.join(', ') + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\r\n                        }\r\n                        else {\r\n                            errStr = 'Parse error on line ' + (yylineno + 1) + \": Unexpected \" +\r\n                                (symbol == EOF ? \"end of input\" :\r\n                                    (\"'\" + (this.terminals_[symbol] || symbol) + \"'\"));\r\n                        }\r\n                        this.parseError(errStr, {\r\n                            text: lexer.match,\r\n                            token: this.terminals_[symbol] || symbol,\r\n                            line: lexer.yylineno,\r\n                            loc: yyloc,\r\n                            expected: expected,\r\n                            recoverable: (error_rule_depth !== false)\r\n                        });\r\n                    }\r\n                    else if (preErrorSymbol !== EOF) {\r\n                        error_rule_depth = locateNearestErrorRecoveryRule(state);\r\n                    }\r\n                    // just recovered from another error\r\n                    if (recovering == 3) {\r\n                        if (symbol === EOF || preErrorSymbol === EOF) {\r\n                            throw new Error(errStr || 'Parsing halted while starting to recover from another error.');\r\n                        }\r\n                        // discard current lookahead and grab another\r\n                        yyleng = lexer.yyleng;\r\n                        yytext = lexer.yytext;\r\n                        yylineno = lexer.yylineno;\r\n                        yyloc = lexer.yylloc;\r\n                        symbol = lex();\r\n                    }\r\n                    // try to recover from error\r\n                    if (error_rule_depth === false) {\r\n                        throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');\r\n                    }\r\n                    popStack(error_rule_depth);\r\n                    preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token\r\n                    symbol = TERROR; // insert generic error symbol as new lookahead\r\n                    state = stack[stack.length - 1];\r\n                    action = table[state] && table[state][TERROR];\r\n                    recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\r\n                }\r\n                // this shouldn't happen, unless resolve defaults are off\r\n                if (action[0] instanceof Array && action.length > 1) {\r\n                    throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\r\n                }\r\n                switch (action[0]) {\r\n                    case 1: // shift\r\n                        //this.shiftCount++;\r\n                        stack.push(symbol);\r\n                        vstack.push(lexer.yytext);\r\n                        lstack.push(lexer.yylloc);\r\n                        stack.push(action[1]); // push state\r\n                        symbol = null;\r\n                        if (!preErrorSymbol) { // normal execution/no error\r\n                            yyleng = lexer.yyleng;\r\n                            yytext = lexer.yytext;\r\n                            yylineno = lexer.yylineno;\r\n                            yyloc = lexer.yylloc;\r\n                            if (recovering > 0) {\r\n                                recovering--;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // error just occurred, resume old lookahead f/ before error\r\n                            symbol = preErrorSymbol;\r\n                            preErrorSymbol = null;\r\n                        }\r\n                        break;\r\n                    case 2:\r\n                        // reduce\r\n                        //this.reductionCount++;\r\n                        len = this.productions_[action[1]][1];\r\n                        // perform semantic action\r\n                        yyval.$ = vstack[vstack.length - len]; // default to $$ = $1\r\n                        // default location, uses first token for firsts, last for lasts\r\n                        yyval._$ = {\r\n                            first_line: lstack[lstack.length - (len || 1)].first_line,\r\n                            last_line: lstack[lstack.length - 1].last_line,\r\n                            first_column: lstack[lstack.length - (len || 1)].first_column,\r\n                            last_column: lstack[lstack.length - 1].last_column\r\n                        };\r\n                        if (ranges) {\r\n                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];\r\n                        }\r\n                        r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));\r\n                        if (typeof r !== 'undefined') {\r\n                            return r;\r\n                        }\r\n                        // pop off stack\r\n                        if (len) {\r\n                            stack = stack.slice(0, -1 * len * 2);\r\n                            vstack = vstack.slice(0, -1 * len);\r\n                            lstack = lstack.slice(0, -1 * len);\r\n                        }\r\n                        stack.push(this.productions_[action[1]][0]); // push nonterminal (reduce)\r\n                        vstack.push(yyval.$);\r\n                        lstack.push(yyval._$);\r\n                        // goto new state = table[STATE][NONTERMINAL]\r\n                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\r\n                        stack.push(newState);\r\n                        break;\r\n                    case 3:\r\n                        // accept\r\n                        return true;\r\n                }\r\n            }\r\n            return true;\r\n        } };\r\n    const { TipoSeleccion } = require('../Xpath/TipoSeleccion');\r\n    const { OpBinaria } = require('../Xpath/OpBinaria');\r\n    const { TiposOp } = require('../Xpath/TiposOp');\r\n    const { Primitivo } = require('../Xpath/Primitivo');\r\n    const { TipoVal } = require('../Xpath/TipoVal');\r\n    const { ControlError } = require('../Xpath/ControlError');\r\n    listaError = [];\r\n    /* generated by jison-lex 0.3.4 */\r\n    var lexer = (function () {\r\n        var lexer = ({\r\n            EOF: 1,\r\n            parseError: function parseError(str, hash) {\r\n                if (this.yy.parser) {\r\n                    this.yy.parser.parseError(str, hash);\r\n                }\r\n                else {\r\n                    throw new Error(str);\r\n                }\r\n            },\r\n            // resets the lexer, sets new input\r\n            setInput: function (input, yy) {\r\n                this.yy = yy || this.yy || {};\r\n                this._input = input;\r\n                this._more = this._backtrack = this.done = false;\r\n                this.yylineno = this.yyleng = 0;\r\n                this.yytext = this.matched = this.match = '';\r\n                this.conditionStack = ['INITIAL'];\r\n                this.yylloc = {\r\n                    first_line: 1,\r\n                    first_column: 0,\r\n                    last_line: 1,\r\n                    last_column: 0\r\n                };\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [0, 0];\r\n                }\r\n                this.offset = 0;\r\n                return this;\r\n            },\r\n            // consumes and returns one char from the input\r\n            input: function () {\r\n                var ch = this._input[0];\r\n                this.yytext += ch;\r\n                this.yyleng++;\r\n                this.offset++;\r\n                this.match += ch;\r\n                this.matched += ch;\r\n                var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\r\n                if (lines) {\r\n                    this.yylineno++;\r\n                    this.yylloc.last_line++;\r\n                }\r\n                else {\r\n                    this.yylloc.last_column++;\r\n                }\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range[1]++;\r\n                }\r\n                this._input = this._input.slice(1);\r\n                return ch;\r\n            },\r\n            // unshifts one char (or a string) into the input\r\n            unput: function (ch) {\r\n                var len = ch.length;\r\n                var lines = ch.split(/(?:\\r\\n?|\\n)/g);\r\n                this._input = ch + this._input;\r\n                this.yytext = this.yytext.substr(0, this.yytext.length - len);\r\n                //this.yyleng -= len;\r\n                this.offset -= len;\r\n                var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\r\n                this.match = this.match.substr(0, this.match.length - 1);\r\n                this.matched = this.matched.substr(0, this.matched.length - 1);\r\n                if (lines.length - 1) {\r\n                    this.yylineno -= lines.length - 1;\r\n                }\r\n                var r = this.yylloc.range;\r\n                this.yylloc = {\r\n                    first_line: this.yylloc.first_line,\r\n                    last_line: this.yylineno + 1,\r\n                    first_column: this.yylloc.first_column,\r\n                    last_column: lines ?\r\n                        (lines.length === oldLines.length ? this.yylloc.first_column : 0)\r\n                            + oldLines[oldLines.length - lines.length].length - lines[0].length :\r\n                        this.yylloc.first_column - len\r\n                };\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];\r\n                }\r\n                this.yyleng = this.yytext.length;\r\n                return this;\r\n            },\r\n            // When called from action, caches matched text and appends it on next action\r\n            more: function () {\r\n                this._more = true;\r\n                return this;\r\n            },\r\n            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\r\n            reject: function () {\r\n                if (this.options.backtrack_lexer) {\r\n                    this._backtrack = true;\r\n                }\r\n                else {\r\n                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\r\n                        text: \"\",\r\n                        token: null,\r\n                        line: this.yylineno\r\n                    });\r\n                }\r\n                return this;\r\n            },\r\n            // retain first n characters of the match\r\n            less: function (n) {\r\n                this.unput(this.match.slice(n));\r\n            },\r\n            // displays already matched input, i.e. for error messages\r\n            pastInput: function () {\r\n                var past = this.matched.substr(0, this.matched.length - this.match.length);\r\n                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\\n/g, \"\");\r\n            },\r\n            // displays upcoming input, i.e. for error messages\r\n            upcomingInput: function () {\r\n                var next = this.match;\r\n                if (next.length < 20) {\r\n                    next += this._input.substr(0, 20 - next.length);\r\n                }\r\n                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\r\n            },\r\n            // displays the character position where the lexing error occurred, i.e. for error messages\r\n            showPosition: function () {\r\n                var pre = this.pastInput();\r\n                var c = new Array(pre.length + 1).join(\"-\");\r\n                return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\r\n            },\r\n            // test the lexed token: return FALSE when not a match, otherwise return token\r\n            test_match: function (match, indexed_rule) {\r\n                var token, lines, backup;\r\n                if (this.options.backtrack_lexer) {\r\n                    // save context\r\n                    backup = {\r\n                        yylineno: this.yylineno,\r\n                        yylloc: {\r\n                            first_line: this.yylloc.first_line,\r\n                            last_line: this.last_line,\r\n                            first_column: this.yylloc.first_column,\r\n                            last_column: this.yylloc.last_column\r\n                        },\r\n                        yytext: this.yytext,\r\n                        match: this.match,\r\n                        matches: this.matches,\r\n                        matched: this.matched,\r\n                        yyleng: this.yyleng,\r\n                        offset: this.offset,\r\n                        _more: this._more,\r\n                        _input: this._input,\r\n                        yy: this.yy,\r\n                        conditionStack: this.conditionStack.slice(0),\r\n                        done: this.done\r\n                    };\r\n                    if (this.options.ranges) {\r\n                        backup.yylloc.range = this.yylloc.range.slice(0);\r\n                    }\r\n                }\r\n                lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\r\n                if (lines) {\r\n                    this.yylineno += lines.length;\r\n                }\r\n                this.yylloc = {\r\n                    first_line: this.yylloc.last_line,\r\n                    last_line: this.yylineno + 1,\r\n                    first_column: this.yylloc.last_column,\r\n                    last_column: lines ?\r\n                        lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\r\n                        this.yylloc.last_column + match[0].length\r\n                };\r\n                this.yytext += match[0];\r\n                this.match += match[0];\r\n                this.matches = match;\r\n                this.yyleng = this.yytext.length;\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [this.offset, this.offset += this.yyleng];\r\n                }\r\n                this._more = false;\r\n                this._backtrack = false;\r\n                this._input = this._input.slice(match[0].length);\r\n                this.matched += match[0];\r\n                token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\r\n                if (this.done && this._input) {\r\n                    this.done = false;\r\n                }\r\n                if (token) {\r\n                    return token;\r\n                }\r\n                else if (this._backtrack) {\r\n                    // recover context\r\n                    for (var k in backup) {\r\n                        this[k] = backup[k];\r\n                    }\r\n                    return false; // rule action called reject() implying the next rule should be tested instead.\r\n                }\r\n                return false;\r\n            },\r\n            // return next match in input\r\n            next: function () {\r\n                if (this.done) {\r\n                    return this.EOF;\r\n                }\r\n                if (!this._input) {\r\n                    this.done = true;\r\n                }\r\n                var token, match, tempMatch, index;\r\n                if (!this._more) {\r\n                    this.yytext = '';\r\n                    this.match = '';\r\n                }\r\n                var rules = this._currentRules();\r\n                for (var i = 0; i < rules.length; i++) {\r\n                    tempMatch = this._input.match(this.rules[rules[i]]);\r\n                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\r\n                        match = tempMatch;\r\n                        index = i;\r\n                        if (this.options.backtrack_lexer) {\r\n                            token = this.test_match(tempMatch, rules[i]);\r\n                            if (token !== false) {\r\n                                return token;\r\n                            }\r\n                            else if (this._backtrack) {\r\n                                match = false;\r\n                                continue; // rule action called reject() implying a rule MISmatch.\r\n                            }\r\n                            else {\r\n                                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n                                return false;\r\n                            }\r\n                        }\r\n                        else if (!this.options.flex) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (match) {\r\n                    token = this.test_match(match, rules[index]);\r\n                    if (token !== false) {\r\n                        return token;\r\n                    }\r\n                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n                    return false;\r\n                }\r\n                if (this._input === \"\") {\r\n                    return this.EOF;\r\n                }\r\n                else {\r\n                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\r\n                        text: \"\",\r\n                        token: null,\r\n                        line: this.yylineno\r\n                    });\r\n                }\r\n            },\r\n            // return next match that has a token\r\n            lex: function lex() {\r\n                var r = this.next();\r\n                if (r) {\r\n                    return r;\r\n                }\r\n                else {\r\n                    return this.lex();\r\n                }\r\n            },\r\n            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\r\n            begin: function begin(condition) {\r\n                this.conditionStack.push(condition);\r\n            },\r\n            // pop the previously active lexer condition state off the condition stack\r\n            popState: function popState() {\r\n                var n = this.conditionStack.length - 1;\r\n                if (n > 0) {\r\n                    return this.conditionStack.pop();\r\n                }\r\n                else {\r\n                    return this.conditionStack[0];\r\n                }\r\n            },\r\n            // produce the lexer rule set which is active for the currently active lexer condition state\r\n            _currentRules: function _currentRules() {\r\n                if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\r\n                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\r\n                }\r\n                else {\r\n                    return this.conditions[\"INITIAL\"].rules;\r\n                }\r\n            },\r\n            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\r\n            topState: function topState(n) {\r\n                n = this.conditionStack.length - 1 - Math.abs(n || 0);\r\n                if (n >= 0) {\r\n                    return this.conditionStack[n];\r\n                }\r\n                else {\r\n                    return \"INITIAL\";\r\n                }\r\n            },\r\n            // alias for begin(condition)\r\n            pushState: function pushState(condition) {\r\n                this.begin(condition);\r\n            },\r\n            // return the number of states currently on the stack\r\n            stateStackSize: function stateStackSize() {\r\n                return this.conditionStack.length;\r\n            },\r\n            options: { \"case-insensitive\": true },\r\n            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\r\n                var YYSTATE = YY_START;\r\n                switch ($avoiding_name_collisions) {\r\n                    case 0:\r\n                        break;\r\n                    case 1:\r\n                        return 'menor';\r\n                        break;\r\n                    case 2:\r\n                        return 'mayor';\r\n                        break;\r\n                    case 3:\r\n                        return 11;\r\n                        break;\r\n                    case 4:\r\n                        return 10;\r\n                        break;\r\n                    case 5:\r\n                        return 'igual';\r\n                        break;\r\n                    case 6:\r\n                        return 6;\r\n                        break;\r\n                    case 7:\r\n                        return 21;\r\n                        break;\r\n                    case 8:\r\n                        return 22;\r\n                        break;\r\n                    case 9:\r\n                        return 17;\r\n                        break;\r\n                    case 10:\r\n                        return 'div';\r\n                        break;\r\n                    case 11:\r\n                        return 'noIgual';\r\n                        break;\r\n                    case 12:\r\n                        return 'mayorQue';\r\n                        break;\r\n                    case 13:\r\n                        return 'menorQue';\r\n                        break;\r\n                    case 14:\r\n                        return 'and';\r\n                        break;\r\n                    case 15:\r\n                        return 'or';\r\n                        break;\r\n                    case 16:\r\n                        return '@';\r\n                        break;\r\n                    case 17:\r\n                        return 16;\r\n                        break;\r\n                    case 18:\r\n                        return 15;\r\n                        break;\r\n                    case 19:\r\n                        return 'dobleDosPuntos';\r\n                        break;\r\n                    case 20:\r\n                        return 18;\r\n                        break;\r\n                    case 21:\r\n                        return 20;\r\n                        break;\r\n                    case 22:\r\n                        return 'parentesisA';\r\n                        break;\r\n                    case 23:\r\n                        return 'parentesisC';\r\n                        break;\r\n                    case 24:\r\n                        return 'ancestor';\r\n                        break;\r\n                    case 25:\r\n                        return 'ancestor-or-self';\r\n                        break;\r\n                    case 26:\r\n                        return 'attribute';\r\n                        break;\r\n                    case 27:\r\n                        return 'child';\r\n                        break;\r\n                    case 28:\r\n                        return 'descendant';\r\n                        break;\r\n                    case 29:\r\n                        return 'descendant-or-self';\r\n                        break;\r\n                    case 30:\r\n                        return 'following';\r\n                        break;\r\n                    case 31:\r\n                        return 'following-sibling';\r\n                        break;\r\n                    case 32:\r\n                        return \"namespace\";\r\n                        break;\r\n                    case 33:\r\n                        return 'parent';\r\n                        break;\r\n                    case 34:\r\n                        return 'preceding';\r\n                        break;\r\n                    case 35:\r\n                        return 'preceding-sibling';\r\n                        break;\r\n                    case 36:\r\n                        return 'self';\r\n                        break;\r\n                    case 37:\r\n                        return 'NODO';\r\n                        break;\r\n                    case 38:\r\n                        return 'LANG';\r\n                        break;\r\n                    case 39:\r\n                        return 'POSICION';\r\n                        break;\r\n                    case 40:\r\n                        return 'ULTIMO';\r\n                        break;\r\n                    case 41:\r\n                        return 'TEXTO';\r\n                        break;\r\n                    case 42:\r\n                        return 'CADENA';\r\n                        break;\r\n                    case 43:\r\n                        return 24;\r\n                        break;\r\n                    case 44:\r\n                        return 23;\r\n                        break;\r\n                    case 45:\r\n                        return 12;\r\n                        break;\r\n                    case 46:\r\n                        return 5;\r\n                        break;\r\n                    case 47:\r\n                        new ControlError(yy_.yytext, TipoSeleccion.ERROR_LEXICO, yy_.yylloc.first_line, yy_.yylloc.first_column, \"XpathAscendente\");\r\n                        break;\r\n                }\r\n            },\r\n            rules: [/^(?:[\\s]+)/i, /^(?:<)/i, /^(?:>)/i, /^(?:\\/\\/)/i, /^(?:\\/)/i, /^(?:=)/i, /^(?:\\|)/i, /^(?:\\+)/i, /^(?:-)/i, /^(?:\\*)/i, /^(?:div\\b)/i, /^(?:!=)/i, /^(?:>=)/i, /^(?:<=)/i, /^(?:and\\b)/i, /^(?:or\\b)/i, /^(?:@)/i, /^(?:\\.)/i, /^(?:\\.\\.)/i, /^(?:::)/i, /^(?:\\[)/i, /^(?:\\])/i, /^(?:\\()/i, /^(?:\\))/i, /^(?:ancestor\\b)/i, /^(?:ancestor-or-self\\b)/i, /^(?:attribute\\b)/i, /^(?:child\\b)/i, /^(?:descendant\\b)/i, /^(?:descendant-or-self\\b)/i, /^(?:following\\b)/i, /^(?:following-sibling\\b)/i, /^(?:namespace\\b)/i, /^(?:parent\\b)/i, /^(?:preceding\\b)/i, /^(?:preceding-sibling\\b)/i, /^(?:self\\b)/i, /^(?:node\\b)/i, /^(?:lang\\b)/i, /^(?:position\\b)/i, /^(?:last\\b)/i, /^(?:text\\b)/i, /^(?:'[^\\']*')/i, /^(?:[0-9]+(\\.[0-9]+)\\b)/i, /^(?:[0-9]+\\b)/i, /^(?:[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:$)/i, /^(?:.)/i],\r\n            conditions: { \"INITIAL\": { \"rules\": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47], \"inclusive\": true } }\r\n        });\r\n        return lexer;\r\n    })();\r\n    parser.lexer = lexer;\r\n    function Parser() {\r\n        this.yy = {};\r\n    }\r\n    Parser.prototype = parser;\r\n    parser.Parser = Parser;\r\n    return new Parser;\r\n})();\r\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\r\n    exports.parser = xpathA;\r\n    exports.Parser = xpathA.Parser;\r\n    exports.parse = function () { return xpathA.parse.apply(xpathA, arguments); };\r\n    exports.main = function commonjsMain(args) {\r\n        if (!args[1]) {\r\n            console.log('Usage: ' + args[0] + ' FILE');\r\n            process.exit(1);\r\n        }\r\n        var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\r\n        return exports.parser.parse(source);\r\n    };\r\n    if (typeof module !== 'undefined' && require.main === module) {\r\n        exports.main(process.argv.slice(1));\r\n    }\r\n}\r\n","import { Component } from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'app-root',\r\n  templateUrl: './app.component.html',\r\n  styleUrls: ['./app.component.css']\r\n})\r\nexport class AppComponent {\r\n  title = 'frontend';\r\n}\r\n","<router-outlet></router-outlet>","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Fila_1 = require(\"./Fila\");\r\nconst Tipos_1 = require(\"./Tipos\");\r\nconst Tabla_1 = require(\"./Tabla\");\r\nconst Graficas_1 = require(\"../Graficas/Graficas\");\r\nclass EtiquetaSimple {\r\n    constructor(nombreTag, listaAtributos, linea, columna, idSent) {\r\n        this.nombreTag = nombreTag;\r\n        this.padre = null;\r\n        this.listaAtributos = listaAtributos;\r\n        this.linea = linea;\r\n        this.columna = columna;\r\n        this.idSent = idSent;\r\n        this.listaAtributos.forEach(atributo => {\r\n            atributo.etiquetaContendora = this;\r\n        });\r\n    }\r\n    getName() {\r\n        return this.nombreTag;\r\n    }\r\n    getAmbito() {\r\n        let listaAmbito = [];\r\n        for (let etiqueta = this.padre; etiqueta != null; etiqueta = etiqueta.padre) {\r\n            listaAmbito.push(etiqueta.getName());\r\n        }\r\n        listaAmbito.push(\"GLOBAL\");\r\n        return listaAmbito;\r\n    }\r\n    imprimir() {\r\n        let texto = \"\";\r\n        texto += \"<\" + this.nombreTag;\r\n        this.listaAtributos.forEach(atributo => {\r\n            texto += \" \" + atributo.imprimir();\r\n        });\r\n        texto += \"/> \\n\";\r\n        return texto;\r\n    }\r\n    getAsTable() {\r\n        let tabla = new Tabla_1.Tabla();\r\n        tabla.addFila(new Fila_1.Fila(this.getName(), Tipos_1.Tipos.ETIQUETA_SIMPLE, this.getAmbito(), this.linea, this.columna, this.imprimir()));\r\n        this.listaAtributos.forEach(atributo => {\r\n            tabla.addFila(atributo.getAsRowTable());\r\n        });\r\n        return tabla;\r\n    }\r\n    getErroresSemanticos() {\r\n        let texto = \"\";\r\n        this.listaAtributos.forEach(atributo => {\r\n            let apariciones = 0;\r\n            for (let atr2 of this.listaAtributos) {\r\n                if (atributo.nombre == atr2.nombre) {\r\n                    apariciones += 1;\r\n                }\r\n                if (apariciones > 1) {\r\n                    texto += `Error(Linea: ${atributo.linea}, Columna: ${atributo.columna}): El atributo '${atributo.nombre}' se encuentra repetido.\\n`;\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n        return texto;\r\n    }\r\n    getCstDotA(idPadre) {\r\n        let texto = \"\";\r\n        texto += Graficas_1.Graficas.getElement(this.idSent, \"TAG_UNICO\", idPadre);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 1, \"AbreTagCierre\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 2, \"<\" + this.nombreTag, this.idSent + 1);\r\n        if (this.listaAtributos.length > 0) {\r\n            let cont = 3;\r\n            for (let atributo of this.listaAtributos) {\r\n                if (cont - 3 != this.listaAtributos.length - 1) {\r\n                    texto += Graficas_1.Graficas.getElement(this.idSent + cont, \"LISTA_ATRIBUTOS\", this.idSent + cont + 1);\r\n                    texto += atributo.getCstDotA(this.idSent + cont);\r\n                }\r\n                else {\r\n                    texto += Graficas_1.Graficas.getElement(this.idSent + cont, \"LISTA_ATRIBUTOS\", this.idSent);\r\n                    texto += atributo.getCstDotA(this.idSent + cont);\r\n                }\r\n                cont += 1;\r\n            }\r\n        }\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 3 + this.listaAtributos.length, \"CierreTagCierre\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 4 + this.listaAtributos.length, \"\\\\>\", this.idSent + 3 + this.listaAtributos.length);\r\n        return texto;\r\n    }\r\n    getCstDotD(idPadre) {\r\n        let texto = \"\";\r\n        texto += Graficas_1.Graficas.getElement(this.idSent, \"TAG_UNICO\", idPadre);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 1, \"AbreTagCierre\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 2, \"<\" + this.nombreTag, this.idSent + 1);\r\n        if (this.listaAtributos.length > 0) {\r\n            let cont = 3;\r\n            for (let atributo of this.listaAtributos) {\r\n                let cont = 3;\r\n                for (let atributo of this.listaAtributos) {\r\n                    if (cont === 3) {\r\n                        texto += Graficas_1.Graficas.getElement(this.idSent + cont, \"LISTA_ATRIBUTOS\", this.idSent + 1);\r\n                        texto += atributo.getCstDotA(this.idSent + cont);\r\n                    }\r\n                    else {\r\n                        texto += Graficas_1.Graficas.getElement(this.idSent + cont, \"LISTA_ATRIBUTOS\", this.idSent + cont - 1);\r\n                        texto += atributo.getCstDotA(this.idSent + cont);\r\n                    }\r\n                    cont += 1;\r\n                }\r\n            }\r\n        }\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 3 + this.listaAtributos.length, \"CierreTagCierre\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 4 + this.listaAtributos.length, \"\\\\>\", this.idSent + 3 + this.listaAtributos.length);\r\n        return texto;\r\n    }\r\n}\r\nexports.EtiquetaSimple = EtiquetaSimple;\r\n","import { Component, OnInit, ViewChild } from '@angular/core';\r\nimport { FormControl } from '@angular/forms';\r\nimport { Observable } from 'rxjs';\r\nimport { CompiladorService } from 'src/app/services/compilador.service'\r\nimport { saveAs } from 'file-saver'\r\nimport { DomSanitizer } from '@angular/platform-browser';\r\nimport * as vis from \"vis\";\r\n\r\n\r\nimport { Buffer } from 'buffer/';\r\n//importamos para el editor\r\nimport { filter, take } from 'rxjs/operators';\r\nimport {\r\n  MonacoEditorComponent,\r\n  MonacoEditorConstructionOptions,\r\n  MonacoEditorLoaderService,\r\n  MonacoStandaloneCodeEditor\r\n} from '@materia-ui/ngx-monaco-editor';\r\nimport { THIS_EXPR } from '@angular/compiler/src/output/output_ast';\r\nimport { interpolateCividis } from 'd3';\r\n\r\n@Component({\r\n  selector: 'app-editor',\r\n  templateUrl: './editor.component.html',\r\n  styleUrls: ['./editor.component.css']\r\n})\r\nexport class EditorComponent implements OnInit {\r\n  nombreArchivo = \"Choose file\"\r\n  archivo: any\r\n  reporteSelccionado: string = \"\"\r\n\r\n  textoEditores: string[] = [\"\"]\r\n  ReporteGramatica: any\r\n \r\n  XPATH :string []=[\"\"]\r\n  indiceEditorActual = 0\r\n  console: string = \"\";\r\n  xpath: string = \"\";\r\n  astJson: any\r\n  Error:any;\r\n  tablaSimbolos: any\r\n  astBase64: any\r\n\r\n  @ViewChild(MonacoEditorComponent, { static: false })\r\n  monacoComponent: MonacoEditorComponent = new MonacoEditorComponent(this.monacoLoaderService);\r\n  editorOptions: MonacoEditorConstructionOptions = {\r\n    theme: 'myCustomTheme',\r\n    language: '',\r\n    roundedSelection: true,\r\n    autoIndent: \"full\"\r\n  };\r\n\r\n  consoleOptions: MonacoEditorConstructionOptions = {\r\n    theme: 'myCustomTheme',\r\n    language: 'XML',\r\n    roundedSelection: true,\r\n    autoIndent: \"full\",\r\n    readOnly: true\r\n  };\r\n  XpathOptions: MonacoEditorConstructionOptions = {\r\n    theme: 'myCustomTheme',\r\n    language: '',\r\n    roundedSelection: true,\r\n    autoIndent: \"full\",\r\n    readOnly: true\r\n  };\r\n  constructor(private sanitizer: DomSanitizer, private monacoLoaderService: MonacoEditorLoaderService,\r\n    private compiladorService: CompiladorService) {\r\n    this.monacoLoaderService.isMonacoLoaded$\r\n      .pipe(\r\n        filter(isLoaded => isLoaded),\r\n        take(1)\r\n      )\r\n      .subscribe(() => {\r\n        monaco.editor.defineTheme('myCustomTheme', {\r\n          base: 'vs-dark', // can also be vs or hc-black\r\n          inherit: true, // can also be false to completely replace the builtin rules\r\n          rules: [\r\n            {\r\n              token: 'comment',\r\n              foreground: 'ffa500',\r\n              fontStyle: 'italic underline'\r\n            },\r\n            { token: 'comment.js', foreground: '008800', fontStyle: 'bold' },\r\n            { token: 'comment.css', foreground: '0000ff' } // will inherit fontStyle from `comment` above\r\n          ],\r\n          colors: {}\r\n        });\r\n      });\r\n  }\r\n\r\n  editorInit(editor: MonacoStandaloneCodeEditor) {\r\n    editor.setSelection({\r\n      startLineNumber: 1,\r\n      startColumn: 1,\r\n      endColumn: 500,\r\n      endLineNumber: 3\r\n    });\r\n  }\r\n\r\n  ngOnInit(): void {\r\n  }\r\n\r\n  compilar() {\r\n    this.console = \"\"\r\n     console.log(this.XPATH[this.indiceEditorActual])\r\n    this.xpath = \"\"\r\n    this.astJson = []\r\n    this.tablaSimbolos = this.compiladorService.analizar(this.textoEditores[this.indiceEditorActual] ,this.XPATH[this.indiceEditorActual] ).simbolo\r\n   // this.compiladorService.analizar(this.textoEditores[this.indiceEditorActual])\r\n   // viz(\"string en dot\")\r\n   // format: 'png-image-element'\r\n    /*   this.console = res.consola\r\n      this.astJson = res.arbol\r\n      this.tablaSimbolos = res.tablaSimbolos\r\n      this.astBase64 = this.sanitizer.bypassSecurityTrustResourceUrl(`data:image;base64, ${res.astBase64}`)\r\n    */\r\n\r\n      this.ReporteGramatica=this.compiladorService.analizar(this.textoEditores[this.indiceEditorActual] ,this.XPATH[this.indiceEditorActual] ).ReporteGramatica\r\nconsole.log(\"Encoding:::::::::::::::::::\"+this.compiladorService.analizar(this.textoEditores[this.indiceEditorActual] ,this.XPATH[this.indiceEditorActual] ).Encoding)\r\nlet ascii=\"\\\"ASCII\\\"\"  \r\n\r\nif  (this.compiladorService.analizar(this.textoEditores[this.indiceEditorActual] ,this.XPATH[this.indiceEditorActual] ).Encoding==ascii){\r\n    var buf = new Buffer(this.compiladorService.analizar(this.textoEditores[this.indiceEditorActual],this.XPATH[this.indiceEditorActual]).consulta)\r\nthis.console=buf.toString(\"ascii\")\r\n\r\nconsole.log(\"adentro del ascii\") \r\n\r\n  }\r\n  else if (this.compiladorService.analizar(this.textoEditores[this.indiceEditorActual] ,this.XPATH[this.indiceEditorActual] ).Encoding===\"ISO-8859-1\"){\r\n    var buf = new Buffer(this.compiladorService.analizar(this.textoEditores[this.indiceEditorActual],this.XPATH[this.indiceEditorActual]).consulta)\r\n    this.console=buf.toString(\"utf8\")\r\n    \r\n  } //\r\n\r\n  else if (this.compiladorService.analizar(this.textoEditores[this.indiceEditorActual] ,this.XPATH[this.indiceEditorActual] ).Encoding===\"\\\"UFT-8\\\" \")\r\n  \r\n  {\r\n\r\n    var buf = new Buffer(this.compiladorService.analizar(this.textoEditores[this.indiceEditorActual],this.XPATH[this.indiceEditorActual]).consulta)\r\n  this.console=buf.toString(\"utf8\")\r\n \r\n\r\n  }\r\n  else {\r\n    //  this.console=buf.toString(\"utf8\")\r\n    //console.log(\"adentro del utf 8\") \r\n    \r\n  //  console.log(\"adentro del utf 8\") \r\n   // this.console.l\r\n   let aux=\"  <TITLE>&apos;Esto tiene que salir muy bien tambien&apos;</TITLE>\"\r\n   //  console.log(\"--*9-*-\"+this.compiladorService.analizar(this.textoEditores[this.indiceEditorActual],this.XPATH[this.indiceEditorActual]).consulta)\r\n    var incov = require('iconv-lite');\r\n    this.console=  incov.decode(aux, \"utf-8\");\r\n   console.log(this.console)\r\n\r\n  }\r\n     this.Error=(this.compiladorService.analizar(this.textoEditores[this.indiceEditorActual],this.XPATH[this.indiceEditorActual]).Error)\r\n  \r\n  this.prueba(this.compiladorService.analizar(this.textoEditores[this.indiceEditorActual],this.XPATH[this.indiceEditorActual]).cst);\r\n\r\n  }\r\n  compilarD() {\r\n    this.console = \"\"\r\n     console.log(this.XPATH[this.indiceEditorActual])\r\n    this.xpath = \"\"\r\n    this.astJson = []\r\n    this.tablaSimbolos = this.compiladorService.analizarD(this.textoEditores[this.indiceEditorActual] ,this.XPATH[this.indiceEditorActual] ).simbolo\r\n   // this.compiladorService.analizar(this.textoEditores[this.indiceEditorActual])\r\n   // viz(\"string en dot\")\r\n   // format: 'png-image-element'\r\n    /*   this.console = res.consola\r\n      this.astJson = res.arbol\r\n      this.tablaSimbolos = res.tablaSimbolos\r\n      this.astBase64 = this.sanitizer.bypassSecurityTrustResourceUrl(`data:image;base64, ${res.astBase64}`)\r\n    */\r\n\r\n      this.ReporteGramatica=this.compiladorService.analizarD(this.textoEditores[this.indiceEditorActual] ,this.XPATH[this.indiceEditorActual] ).ReporteGramatica\r\n    this.console=(this.compiladorService.analizarD(this.textoEditores[this.indiceEditorActual],this.XPATH[this.indiceEditorActual]).consulta)\r\n    this.Error=(this.compiladorService.analizarD(this.textoEditores[this.indiceEditorActual],this.XPATH[this.indiceEditorActual]).Error)\r\n  \r\n  this.prueba(this.compiladorService.analizarD(this.textoEditores[this.indiceEditorActual],this.XPATH[this.indiceEditorActual]).cst);\r\n\r\n  }\r\n  seleccionarArchivo(event: any) {\r\n    this.nombreArchivo = event.target.files[0].name\r\n    this.archivo = event.target.files[0]\r\n  }\r\n  prueba (grafo:string){\r\n //   console.log(\"grafo0000000\"+grafo)\r\n\r\n    const container = document.getElementById(\"app\");\r\n    // provide data in the DOT language\r\n    var DOTstring = grafo;\r\n    var parsedData = vis.network.convertDot(DOTstring);\r\n    var options = parsedData.options;\r\n    options[\"physics\"] = {\r\n      enabled: false\r\n    };\r\n    \r\n    options[\"layout\"] = {\r\n      improvedLayout: true,\r\n      hierarchical: {\r\n        enabled: true,\r\n        levelSeparation: 150,\r\n        treeSpacing: 35,\r\n        blockShifting: true,\r\n        edgeMinimization: true,\r\n        parentCentralization: true,\r\n        direction: \"UD\",\r\n        sortMethod: \"directed\"\r\n      },\r\n      font: {\r\n          size: 15,\r\n          color: 'gray'\r\n      },\r\n      borderWidth: 2\r\n    };\r\n    \r\n    \r\n    \r\n    var network = new vis.Network(container, parsedData, options);\r\n    \r\n    network.on(\"stabilizationIterationsDone\", function () {\r\n      network.setOptions({ physics: false });\r\n    });\r\n  \r\n  \r\n  \r\n  }\r\n\r\n  cargarArchivo() {\r\n    const reader = new FileReader();\r\n    reader.onload = (e) => {\r\n      const text = reader.result!.toString().trim();\r\n      this.textoEditores[this.indiceEditorActual] = text\r\n    }\r\n    reader.readAsText(this.archivo);\r\n  }\r\n\r\n  agregarTab() {\r\n    this.textoEditores.push(\"\")\r\n    this.indiceEditorActual = this.textoEditores.length - 1\r\n  }\r\n\r\n  eliminarEditor(i: number) {\r\n    if (i != 0) {\r\n      this.textoEditores.splice(i, 1)\r\n      this.indiceEditorActual = 0\r\n    } else {\r\n      this.textoEditores[0] = \"\"\r\n    }\r\n  }\r\n\r\n  guardar() {\r\n    var file = new File([this.textoEditores[this.indiceEditorActual]], \"Codigo.ty\", {\r\n      type: \"text/plain\",\r\n    });\r\n    saveAs(file)\r\n  }\r\n\r\n  selectReporte(opcion: string) {\r\n    this.reporteSelccionado = opcion\r\n\r\n  }\r\n\r\n  imprimir() {\r\n  }\r\n\r\n}\r\n","\r\n<nav class=\"navbar navbar-expand-lg navbar-dark \">\r\n    <button class=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarColor01\"\r\n        aria-controls=\"navbarColor01\" aria-expanded=\"false\" aria-label=\"Toggle navigation\">\r\n        <span class=\"navbar-toggler-icon\"></span>\r\n    </button>\r\n\r\n    <div class=\"navbar\" id=\"navbarColor01\">\r\n        <ul class=\"navbar-nav mr-auto\">\r\n            <li class=\"nav-item active\">\r\n                <button (click)=\"selectReporte('editor')\" type=\"button\" class=\"btn btn-primary principal\">Compilador</button>\r\n            </li>\r\n            <li class=\"nav-item\">\r\n                <button (click)=\"selectReporte('arbolAst')\" class=\"btn btn-primary opcion\">Arbol AST</button>\r\n            </li>\r\n            <li class=\"nav-item\">\r\n                <button (click)=\"selectReporte('tablaSimbolos')\" type=\"button\" class=\"btn btn-primary opcion\">REPORTES</button>\r\n            </li>\r\n            <!-- <li class=\"nav-item\">\r\n                <button (click)=\"selectReporte('tablaErrores')\" type=\"button\" class=\"btn btn-primary opcion\">Tabla de Errores</button>\r\n            </li> -->\r\n        </ul>\r\n    </div>\r\n</nav>\r\n\r\n<div class=\"card-body\">\r\n    \r\n<div style=\"width: 850px; height: 400px; margin: auto;\" class=\"monacoCointeiner\">\r\n    <div class=\"card text-white tarjeta\">\r\n        XPATH\r\n                                 \r\n    <ngx-monaco-editor [options]=\"editorOptions\"\r\n    [(ngModel)]=\"XPATH[indiceEditorActual]\" (init)=\"editorInit($event)\" aria-readonly=\"true\">\r\n</ngx-monaco-editor>\r\n</div>\r\n</div>\r\n</div>\r\n<div class=\"container-fluid\">\r\n    <div class=\"row justify-content-center contenedor\">\r\n        <div class=\"col-md-12\">\r\n            <br>\r\n            <div class=\"row\">\r\n                <div class=\"col-md-6\">\r\n                   \r\n                    <div class=\"card text-white tarjeta\">\r\n                    \r\n                        <div class=\"card-header\">\r\n                            <p class=\"lab\">Editor</p>\r\n                            <div *ngFor=\"let texto of textoEditores; let i = index; \"  (click)=\"indiceEditorActual = i\" type=\"button\" class=\"btn btn-primary tab verde\">\r\n                                <div class=\"equis\">TAB_{{i}}</div>\r\n                                <div (click)=\"imprimir()\" type=\"button\" class=\"btn btn-primary equisa verde\" (click)=\"eliminarEditor(i)\">x</div>\r\n                            </div>\r\n                            <button (click)=\"agregarTab()\" type=\"button\" class=\"btn btn-primary mas verde\">+</button>\r\n                            <!-- Button trigger modal -->\r\n                            <button (click)=\"imprimir()\" type=\"button\" class=\"btn btn-primary op mas verde\" data-toggle=\"modal\" data-target=\"#exampleModal\">\r\n                                Cargar Archivo\r\n                            </button>\r\n                            <button (click)=\"guardar()\" type=\"button\" class=\"btn btn-primary op mas verde\">Guardar</button>\r\n                         \r\n                   \r\n                        </div>\r\n\r\n                    \r\n                        <div class=\"card-body\">\r\n                            <div style=\"width: auto; height: 450px;\" class=\"monacoCointeiner\">\r\n                                <ngx-monaco-editor [options]=\"editorOptions\"\r\n                                    [(ngModel)]=\"textoEditores[indiceEditorActual]\" (init)=\"editorInit($event)\"></ngx-monaco-editor>\r\n                            </div>\r\n\r\n                          \r\n                        </div>\r\n                        <br>\r\n                    </div>\r\n                </div>\r\n                <div class=\"col-md-6\">\r\n                    <div class=\"card text-white tarjeta\">\r\n                        <div class=\"card-header\">\r\n                            Consola\r\n                            <button (click)=\"compilar()\" type=\"button\" class=\"btn btn-primary mas verde\">Compilador Ascendente</button>\r\n                          \r\n                            <button (click)=\"console=''\" type=\"button\" class=\"btn btn-primary mas op verde\">Limpiar</button>\r\n                            <button (click)=\"compilarD()\" type=\"button\" class=\"btn btn-primary mas verde\">Compilador Descendente</button>\r\n                            \r\n                        </div>\r\n                       \r\n                        <div class=\"card-body\">\r\n                            <div style=\"width: auto; height: 458px;\" class=\"monacoCointeiner\">\r\n                                <ngx-monaco-editor [options]=\"consoleOptions\"\r\n                                    [(ngModel)]=\"console\" (init)=\"editorInit($event)\" aria-readonly=\"true\">\r\n                                </ngx-monaco-editor>\r\n                         \r\n                            </div>\r\n\r\n                        </div>\r\n                        <br>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <div id=\"app\"  style=\"width: auto; height: 1000px;\" >\r\n        <img [src]=\"astBase64\" class=\"zoom\">\r\n\r\n\r\n    </div>\r\n    <div *ngIf=\"reporteSelccionado === 'tablaSimbolos'\">\r\n\r\n        \r\n        <div class=\"row justify-content-center tabla\">\r\n            <div class=\"col-md-8 tab\">\r\n                <ul class=\"nav nav-tabs justify-content-center\">\r\n                    <li class=\"nav-item active\">\r\n                        <a class=\"nav-link active\" data-toggle=\"tab\" href=\"#simbolos\">Tabla de Símbolos</a>\r\n                    </li>\r\n                </ul>\r\n               \r\n                <div id=\"myTabContent\" class=\"tab-content\">\r\n                    <div class=\"tab-pane fade in active show\" id=\"simbolos\">\r\n                        <div class=\"col-md-12\">\r\n                            <br>\r\n                            <div style=\"width: auto; height: auto;\">\r\n                                <table class=\"table table-hover table-hover\">\r\n                                    <thead>\r\n                                        <tr>\r\n                                            <td>NOMBRE</td>\r\n                                            <td>TIPO_SIMBOLO</td>\r\n                                            <td>AMBITO</td>\r\n                                            <td>COLUMNA</td>\r\n                                            <td>FILA</td>\r\n                                            <td>VALOR</td>\r\n                                        </tr>\r\n                                    </thead>\r\n                                    <tbody>\r\n                                        <tr *ngFor=\"let fila of tablaSimbolos\">\r\n                                            <td>{{fila.nombre}}</td>\r\n                                            <td>{{fila.tipo}}</td>\r\n                                            <td>-{{fila.listaAmbito.join(\"-\")}}-</td>\r\n                                            <td>{{fila.columna}}</td>\r\n                                            <td>{{fila.fila}}</td>\r\n                                            <td>--{{fila.valor}}--</td>\r\n                                        </tr>\r\n                                    \r\n                                    </tbody>\r\n                                </table>\r\n                            </div>\r\n        \r\n                            <div style=\"width: auto; height: auto;\">\r\n                                <ul class=\"nav nav-tabs justify-content-center\">\r\n                                    <li class=\"nav-item active\">\r\n                                        <a class=\"nav-link active\" data-toggle=\"tab\" href=\"#simbolos\">ReporteGramaticaL</a>\r\n                                    </li>\r\n                                </ul>\r\n                                <table class=\"table table-hover table-hover\">\r\n                                    <thead>\r\n                                        <tr>\r\n                                            <td>PRODUCCION</td>\r\n                                            <td>regla_semantica</td>\r\n                                         \r\n                                        </tr>\r\n                                    </thead>\r\n                                    <tbody>\r\n                                        <tr *ngFor=\"let fila of ReporteGramatica\">\r\n                                            <td>{{fila.produccion}}</td>\r\n                                            <td>{{fila.regla_semantica}}</td>\r\n                                        </tr>\r\n                                    \r\n                                    </tbody>\r\n                                </table>\r\n                            </div>\r\n                            <br>\r\n                        </div>\r\n                    </div>\r\n                    <div style=\"width: auto; height: auto;\">\r\n                        <ul class=\"nav nav-tabs justify-content-center\">\r\n                            <li class=\"nav-item active\">\r\n                                <a class=\"nav-link active\" data-toggle=\"tab\" href=\"#simbolos\">ERRORES</a>\r\n                            </li>\r\n                        </ul>\r\n\r\n                     \r\n                        <table class=\"table table-hover table-hover\">\r\n                            <thead>\r\n                                <tr> \r\n                                    <td>SIMBOLO</td>\r\n                                    <td>TIPO</td>\r\n                                    <td>Linea</td>\r\n                                    <td>Columna</td>\r\n                                    <td>Entorno</td>\r\n                                    \r\n                                 \r\n                                </tr>\r\n                            </thead>\r\n                            <tbody>\r\n                                <tr *ngFor=\"let fila of Error\">\r\n                                    <td>{{fila.simbolo}}</td>\r\n                                    <td>{{fila.tipo}}</td>\r\n                                    <td>{{fila.linea}}</td>\r\n                                    <td>{{fila.columna}}</td>\r\n                                    <td>{{fila.entorno}}</td>\r\n                                </tr>\r\n                            \r\n                            </tbody>\r\n                        </table>\r\n                    </div>\r\n                    <div class=\"tab-pane fade\" id=\"errores\">\r\n                        <div class=\"col-md-12\">\r\n                            <br>\r\n                            <div style=\"width: auto; height: auto;\">\r\n                                <table class=\"table table-danger table-hover\">\r\n                                    <thead>\r\n                                        <tr>\r\n                                            <td>hola</td>\r\n                                            <td>mundo</td>\r\n                                        </tr>\r\n                                    </thead>\r\n                                    <tbody>\r\n                                        <tr>\r\n                                            <td>1</td>\r\n                                            <td>2</td>\r\n                                        </tr>\r\n                                    </tbody>\r\n                                </table>\r\n                            </div>\r\n                            <br>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n    </div>\r\n  \r\n    <div  id =\"app\" *ngIf=\"reporteSelccionado === 'arbolAst'\">\r\n        <img [src]=\"astBase64\" class=\"zoom\">\r\n        alv\r\n    </div>\r\n \r\n   \r\n</div>\r\n<script>\r\n  export  function prueba(){\r\n        console.log(this.astBase64)\r\n \r\n    }\r\n   \r\n\r\n\r\n</script>\r\n<!-- Modal -->\r\n<div class=\"modal fade\" id=\"exampleModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"exampleModalLabel\"\r\n        aria-hidden=\"true\">\r\n    <div class=\"modal-dialog\" role=\"document\">\r\n        <div class=\"modal-content\">\r\n            <div class=\"modal-header\">\r\n                <h5 class=\"modal-title\" id=\"exampleModalLabel\">Cargar archivo de entrada</h5>\r\n            </div>\r\n            <div class=\"modal-body\">\r\n                <div class=\"input-group\">\r\n                    <div class=\"custom-file\">\r\n                        <input type=\"file\" class=\"custom-file-input\" id=\"inputGroupFile01\"\r\n                                aria-describedby=\"inputGroupFileAddon01\" (change)=\"seleccionarArchivo($event)\">\r\n                        <label class=\"custom-file-label\" for=\"inputGroupFile01\" id=\"choosedFile\"\r\n                                accept=\".xml\">{{nombreArchivo}}</label>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"modal-footer\">\r\n                <button type=\"button\" class=\"btn btn-primary\" (click)=\"cargarArchivo()\" data-dismiss=\"modal\">Continuar</button>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n<!-- fin de boostrap -->\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TiposOp;\r\n(function (TiposOp) {\r\n    TiposOp[\"SUMA\"] = \"SUMA\";\r\n    TiposOp[\"RESTA\"] = \"RESTA\";\r\n    TiposOp[\"MULTIPLICACION\"] = \"MULTIPLICACION\";\r\n    TiposOp[\"DIVISION\"] = \"DIVISION\";\r\n    TiposOp[\"MODULO\"] = \"MODULO\";\r\n    TiposOp[\"AND\"] = \"AND\";\r\n    TiposOp[\"OR\"] = \"OR\";\r\n    TiposOp[\"ASIGNACION\"] = \"ASIGNACION\";\r\n    TiposOp[\"NO_IGUAL\"] = \"NO_IGUAL\";\r\n    TiposOp[\"MAYOR_QUE\"] = \"MAYOR_QUE\";\r\n    TiposOp[\"MENOR_QUE\"] = \"MENOR_QUE\";\r\n    TiposOp[\"MAYOR_IGUAL\"] = \"MAYOR_IGUAL\";\r\n    TiposOp[\"MENOR_IGUAL\"] = \"MENOR_IGUAL\";\r\n})(TiposOp = exports.TiposOp || (exports.TiposOp = {}));\r\n","/* parser generated by jison 0.4.18 */\r\n/*\r\n  Returns a Parser object of the following structure:\r\n\r\n  Parser: {\r\n    yy: {}\r\n  }\r\n\r\n  Parser.prototype: {\r\n    yy: {},\r\n    trace: function(),\r\n    symbols_: {associative list: name ==> number},\r\n    terminals_: {associative list: number ==> name},\r\n    productions_: [...],\r\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\r\n    table: [...],\r\n    defaultActions: {...},\r\n    parseError: function(str, hash),\r\n    parse: function(input),\r\n\r\n    lexer: {\r\n        EOF: 1,\r\n        parseError: function(str, hash),\r\n        setInput: function(input),\r\n        input: function(),\r\n        unput: function(str),\r\n        more: function(),\r\n        less: function(n),\r\n        pastInput: function(),\r\n        upcomingInput: function(),\r\n        showPosition: function(),\r\n        test_match: function(regex_match_array, rule_index),\r\n        next: function(),\r\n        lex: function(),\r\n        begin: function(condition),\r\n        popState: function(),\r\n        _currentRules: function(),\r\n        topState: function(),\r\n        pushState: function(condition),\r\n\r\n        options: {\r\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\r\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\r\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\r\n        },\r\n\r\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\r\n        rules: [...],\r\n        conditions: {associative list: name ==> set},\r\n    }\r\n  }\r\n\r\n\r\n  token location info (@$, _$, etc.): {\r\n    first_line: n,\r\n    last_line: n,\r\n    first_column: n,\r\n    last_column: n,\r\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\r\n  }\r\n\r\n\r\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\r\n    text:        (matched text)\r\n    token:       (the produced terminal token, if any)\r\n    line:        (yylineno)\r\n  }\r\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\r\n    loc:         (yylloc)\r\n    expected:    (string describing the set of expected tokens)\r\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\r\n  }\r\n*/\r\nvar xpathD = (function () {\r\n    var o = function (k, v, o, l) { for (o = o || {}, l = k.length; l--; o[k[l]] = v)\r\n        ; return o; }, $V0 = [1, 5], $V1 = [1, 8], $V2 = [1, 9], $V3 = [1, 6], $V4 = [2, 4], $V5 = [1, 12], $V6 = [5, 8], $V7 = [2, 5, 8, 11, 12, 13], $V8 = [13, 16, 19, 20, 21];\r\n    var parser = { trace: function trace() { },\r\n        yy: {},\r\n        symbols_: { \"error\": 2, \"XPATH\": 3, \"CONCATENACION_SETS\": 4, \"EOF\": 5, \"LISTA_SETS\": 6, \"CONCATENACION_SETSAUX\": 7, \"barraVertical\": 8, \"SET\": 9, \"SELECTOR\": 10, \"slash\": 11, \"dobleSlash\": 12, \"identificador\": 13, \"MENU_SELECTOR\": 14, \"MenuIdentificador\": 15, \"arroba\": 16, \"MenuArroba\": 17, \"MENU_SET\": 18, \"dosPuntos\": 19, \"punto\": 20, \"asterisco\": 21, \"PREDICADO\": 22, \"corecheteA\": 23, \"OPERACION\": 24, \"corcheteC\": 25, \"entero\": 26, \"decimal\": 27, \"MENU_OPERACION\": 28, \"mas\": 29, \"menos\": 30, \"$accept\": 0, \"$end\": 1 },\r\n        terminals_: { 2: \"error\", 5: \"EOF\", 8: \"barraVertical\", 11: \"slash\", 12: \"dobleSlash\", 13: \"identificador\", 16: \"arroba\", 19: \"dosPuntos\", 20: \"punto\", 21: \"asterisco\", 23: \"corecheteA\", 25: \"corcheteC\", 26: \"entero\", 27: \"decimal\", 29: \"mas\", 30: \"menos\" },\r\n        productions_: [0, [3, 2], [4, 2], [7, 3], [7, 0], [6, 2], [6, 1], [6, 1], [10, 1], [10, 1], [9, 1], [9, 2], [14, 2], [14, 2], [14, 1], [18, 1], [18, 1], [18, 1], [15, 1], [15, 0], [17, 1], [17, 1], [22, 3], [24, 1], [24, 1], [28, 2], [28, 2], [28, 2], [28, 2]],\r\n        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\r\n            /* this == yyval */\r\n            var $0 = $$.length - 1;\r\n            switch (yystate) {\r\n                case 1:\r\n                    return $$[$0 - 1];\r\n                    break;\r\n                case 2:\r\n                case 3:\r\n                    $$[$0].push($$[$0 - 1]);\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 4:\r\n                    this.$ = [];\r\n                    break;\r\n                case 5:\r\n                    aux = $$[$0];\r\n                    while (aux.next != null) {\r\n                        aux = aux.next;\r\n                    }\r\n                    ;\r\n                    aux.next = $$[$0 - 1];\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 6:\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 7:\r\n                    this.$ = listaError.push(new ControlError(yytext, TipoSeleccion.ERROR_SINTACTICO, this._$.first_line, this._$.first_column, \"XpathDescendente\"));\r\n                    break;\r\n                case 8:\r\n                case 9:\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 10:\r\n                    this.$ = { tipo: TipoSeleccion.ACCESO_NODO_RAIZ, id: $$[$0], next: null };\r\n                    break;\r\n                case 11:\r\n                    this.$ = { tipo: TipoSeleccion.SELECT_NODOS_FROM_NODO, selector: $$[$0 - 1], id: $$[$0].ids, predicado: $$[$0].predicados, next: null };\r\n                    break;\r\n                case 12:\r\n                    this.$ = {\r\n                        ids: $$[$0 - 1],\r\n                        predicados: $$[$0]\r\n                    };\r\n                    break;\r\n                case 18:\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 19:\r\n                    this.$ = null;\r\n                    break;\r\n                case 22:\r\n                    this.$ = $$[$0 - 1];\r\n                    break;\r\n                case 23:\r\n                    this.$ = new Primitivo(parseInt($$[$0]), TipoVal.ENTERO);\r\n                    break;\r\n                case 24:\r\n                    this.$ = new Primitivo(parseFloat($$[$0]), TipoVal.DECIMAL);\r\n                    break;\r\n                case 25:\r\n                    this.$ =\r\n                        {\r\n                            tipo: TiposOp.SUMA,\r\n                            op: $$[$0]\r\n                        };\r\n                    break;\r\n                case 26:\r\n                    this.$ =\r\n                        {\r\n                            tipo: TiposOp.RESTA,\r\n                            op: $$[$0]\r\n                        };\r\n                    break;\r\n                case 27:\r\n                    this.$ =\r\n                        {\r\n                            tipo: TiposOp.MULTIPLICACION,\r\n                            op: $$[$0]\r\n                        };\r\n                    break;\r\n                case 28:\r\n                    this.$ =\r\n                        {\r\n                            tipo: TiposOp.DIVISION,\r\n                            op: $$[$0]\r\n                        };\r\n                    break;\r\n            }\r\n        },\r\n        table: [{ 2: $V0, 3: 1, 4: 2, 6: 3, 9: 4, 10: 7, 11: $V1, 12: $V2, 13: $V3 }, { 1: [3] }, { 5: [1, 10] }, { 5: $V4, 7: 11, 8: $V5 }, o($V6, [2, 6], { 9: 4, 10: 7, 6: 13, 2: $V0, 11: $V1, 12: $V2, 13: $V3 }), o($V6, [2, 7]), o($V7, [2, 10]), { 13: [1, 15], 14: 14, 16: [1, 16], 18: 17, 19: [1, 18], 20: [1, 19], 21: [1, 20] }, o($V8, [2, 8]), o($V8, [2, 9]), { 1: [2, 1] }, { 5: [2, 2] }, { 2: $V0, 6: 21, 9: 4, 10: 7, 11: $V1, 12: $V2, 13: $V3 }, o($V6, [2, 5]), o($V7, [2, 11]), o($V7, [2, 19], { 15: 22, 22: 23, 23: [1, 24] }), { 13: [1, 26], 17: 25, 21: [1, 27] }, o($V7, [2, 14]), o($V7, [2, 15]), o($V7, [2, 16]), o($V7, [2, 17]), { 5: $V4, 7: 28, 8: $V5 }, o($V7, [2, 12]), o($V7, [2, 18]), { 24: 29, 26: [1, 30], 27: [1, 31] }, o($V7, [2, 13]), o($V7, [2, 20]), o($V7, [2, 21]), { 5: [2, 3] }, { 25: [1, 32] }, { 25: [2, 23] }, { 25: [2, 24] }, o($V7, [2, 22])],\r\n        defaultActions: { 10: [2, 1], 11: [2, 2], 28: [2, 3], 30: [2, 23], 31: [2, 24] },\r\n        parseError: function parseError(str, hash) {\r\n            if (hash.recoverable) {\r\n                this.trace(str);\r\n            }\r\n            else {\r\n                var error = new Error(str);\r\n                error.hash = hash;\r\n                throw error;\r\n            }\r\n        },\r\n        parse: function parse(input) {\r\n            var self = this, stack = [0], tstack = [], // token stack\r\n            vstack = [null], // semantic value stack\r\n            lstack = [], // location stack\r\n            table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\r\n            var args = lstack.slice.call(arguments, 1);\r\n            //this.reductionCount = this.shiftCount = 0;\r\n            var lexer = Object.create(this.lexer);\r\n            var sharedState = { yy: {} };\r\n            // copy state\r\n            for (var k in this.yy) {\r\n                if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\r\n                    sharedState.yy[k] = this.yy[k];\r\n                }\r\n            }\r\n            lexer.setInput(input, sharedState.yy);\r\n            sharedState.yy.lexer = lexer;\r\n            sharedState.yy.parser = this;\r\n            if (typeof lexer.yylloc == 'undefined') {\r\n                lexer.yylloc = {};\r\n            }\r\n            var yyloc = lexer.yylloc;\r\n            lstack.push(yyloc);\r\n            var ranges = lexer.options && lexer.options.ranges;\r\n            if (typeof sharedState.yy.parseError === 'function') {\r\n                this.parseError = sharedState.yy.parseError;\r\n            }\r\n            else {\r\n                this.parseError = Object.getPrototypeOf(this).parseError;\r\n            }\r\n            function popStack(n) {\r\n                stack.length = stack.length - 2 * n;\r\n                vstack.length = vstack.length - n;\r\n                lstack.length = lstack.length - n;\r\n            }\r\n            _token_stack: var lex = function () {\r\n                var token;\r\n                token = lexer.lex() || EOF;\r\n                // if token isn't its numeric value, convert\r\n                if (typeof token !== 'number') {\r\n                    token = self.symbols_[token] || token;\r\n                }\r\n                return token;\r\n            };\r\n            var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\r\n            while (true) {\r\n                // retreive state number from top of stack\r\n                state = stack[stack.length - 1];\r\n                // use default actions if available\r\n                if (this.defaultActions[state]) {\r\n                    action = this.defaultActions[state];\r\n                }\r\n                else {\r\n                    if (symbol === null || typeof symbol == 'undefined') {\r\n                        symbol = lex();\r\n                    }\r\n                    // read action for current state and first input\r\n                    action = table[state] && table[state][symbol];\r\n                }\r\n                _handle_error: \r\n                // handle parse error\r\n                if (typeof action === 'undefined' || !action.length || !action[0]) {\r\n                    var error_rule_depth;\r\n                    var errStr = '';\r\n                    // Return the rule stack depth where the nearest error rule can be found.\r\n                    // Return FALSE when no error recovery rule was found.\r\n                    function locateNearestErrorRecoveryRule(state) {\r\n                        var stack_probe = stack.length - 1;\r\n                        var depth = 0;\r\n                        // try to recover from error\r\n                        for (;;) {\r\n                            // check for error recovery rule in this state\r\n                            if ((TERROR.toString()) in table[state]) {\r\n                                return depth;\r\n                            }\r\n                            if (state === 0 || stack_probe < 2) {\r\n                                return false; // No suitable error recovery rule available.\r\n                            }\r\n                            stack_probe -= 2; // popStack(1): [symbol, action]\r\n                            state = stack[stack_probe];\r\n                            ++depth;\r\n                        }\r\n                    }\r\n                    if (!recovering) {\r\n                        // first see if there's any chance at hitting an error recovery rule:\r\n                        error_rule_depth = locateNearestErrorRecoveryRule(state);\r\n                        // Report error\r\n                        expected = [];\r\n                        for (p in table[state]) {\r\n                            if (this.terminals_[p] && p > TERROR) {\r\n                                expected.push(\"'\" + this.terminals_[p] + \"'\");\r\n                            }\r\n                        }\r\n                        if (lexer.showPosition) {\r\n                            errStr = 'Parse error on line ' + (yylineno + 1) + \":\\n\" + lexer.showPosition() + \"\\nExpecting \" + expected.join(', ') + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\r\n                        }\r\n                        else {\r\n                            errStr = 'Parse error on line ' + (yylineno + 1) + \": Unexpected \" +\r\n                                (symbol == EOF ? \"end of input\" :\r\n                                    (\"'\" + (this.terminals_[symbol] || symbol) + \"'\"));\r\n                        }\r\n                        this.parseError(errStr, {\r\n                            text: lexer.match,\r\n                            token: this.terminals_[symbol] || symbol,\r\n                            line: lexer.yylineno,\r\n                            loc: yyloc,\r\n                            expected: expected,\r\n                            recoverable: (error_rule_depth !== false)\r\n                        });\r\n                    }\r\n                    else if (preErrorSymbol !== EOF) {\r\n                        error_rule_depth = locateNearestErrorRecoveryRule(state);\r\n                    }\r\n                    // just recovered from another error\r\n                    if (recovering == 3) {\r\n                        if (symbol === EOF || preErrorSymbol === EOF) {\r\n                            throw new Error(errStr || 'Parsing halted while starting to recover from another error.');\r\n                        }\r\n                        // discard current lookahead and grab another\r\n                        yyleng = lexer.yyleng;\r\n                        yytext = lexer.yytext;\r\n                        yylineno = lexer.yylineno;\r\n                        yyloc = lexer.yylloc;\r\n                        symbol = lex();\r\n                    }\r\n                    // try to recover from error\r\n                    if (error_rule_depth === false) {\r\n                        throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');\r\n                    }\r\n                    popStack(error_rule_depth);\r\n                    preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token\r\n                    symbol = TERROR; // insert generic error symbol as new lookahead\r\n                    state = stack[stack.length - 1];\r\n                    action = table[state] && table[state][TERROR];\r\n                    recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\r\n                }\r\n                // this shouldn't happen, unless resolve defaults are off\r\n                if (action[0] instanceof Array && action.length > 1) {\r\n                    throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\r\n                }\r\n                switch (action[0]) {\r\n                    case 1: // shift\r\n                        //this.shiftCount++;\r\n                        stack.push(symbol);\r\n                        vstack.push(lexer.yytext);\r\n                        lstack.push(lexer.yylloc);\r\n                        stack.push(action[1]); // push state\r\n                        symbol = null;\r\n                        if (!preErrorSymbol) { // normal execution/no error\r\n                            yyleng = lexer.yyleng;\r\n                            yytext = lexer.yytext;\r\n                            yylineno = lexer.yylineno;\r\n                            yyloc = lexer.yylloc;\r\n                            if (recovering > 0) {\r\n                                recovering--;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // error just occurred, resume old lookahead f/ before error\r\n                            symbol = preErrorSymbol;\r\n                            preErrorSymbol = null;\r\n                        }\r\n                        break;\r\n                    case 2:\r\n                        // reduce\r\n                        //this.reductionCount++;\r\n                        len = this.productions_[action[1]][1];\r\n                        // perform semantic action\r\n                        yyval.$ = vstack[vstack.length - len]; // default to $$ = $1\r\n                        // default location, uses first token for firsts, last for lasts\r\n                        yyval._$ = {\r\n                            first_line: lstack[lstack.length - (len || 1)].first_line,\r\n                            last_line: lstack[lstack.length - 1].last_line,\r\n                            first_column: lstack[lstack.length - (len || 1)].first_column,\r\n                            last_column: lstack[lstack.length - 1].last_column\r\n                        };\r\n                        if (ranges) {\r\n                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];\r\n                        }\r\n                        r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));\r\n                        if (typeof r !== 'undefined') {\r\n                            return r;\r\n                        }\r\n                        // pop off stack\r\n                        if (len) {\r\n                            stack = stack.slice(0, -1 * len * 2);\r\n                            vstack = vstack.slice(0, -1 * len);\r\n                            lstack = lstack.slice(0, -1 * len);\r\n                        }\r\n                        stack.push(this.productions_[action[1]][0]); // push nonterminal (reduce)\r\n                        vstack.push(yyval.$);\r\n                        lstack.push(yyval._$);\r\n                        // goto new state = table[STATE][NONTERMINAL]\r\n                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\r\n                        stack.push(newState);\r\n                        break;\r\n                    case 3:\r\n                        // accept\r\n                        return true;\r\n                }\r\n            }\r\n            return true;\r\n        } };\r\n    const { TipoSeleccion } = require('../Xpath/TipoSeleccion');\r\n    const { OpBinaria } = require('../Xpath/OpBinaria');\r\n    const { TiposOp } = require('../Xpath/TiposOp');\r\n    const { Primitivo } = require('../Xpath/Primitivo');\r\n    const { TipoVal } = require('../Xpath/TipoVal');\r\n    const { ControlError } = require('../Xpath/ControlError');\r\n    listaError = [];\r\n    /* generated by jison-lex 0.3.4 */\r\n    var lexer = (function () {\r\n        var lexer = ({\r\n            EOF: 1,\r\n            parseError: function parseError(str, hash) {\r\n                if (this.yy.parser) {\r\n                    this.yy.parser.parseError(str, hash);\r\n                }\r\n                else {\r\n                    throw new Error(str);\r\n                }\r\n            },\r\n            // resets the lexer, sets new input\r\n            setInput: function (input, yy) {\r\n                this.yy = yy || this.yy || {};\r\n                this._input = input;\r\n                this._more = this._backtrack = this.done = false;\r\n                this.yylineno = this.yyleng = 0;\r\n                this.yytext = this.matched = this.match = '';\r\n                this.conditionStack = ['INITIAL'];\r\n                this.yylloc = {\r\n                    first_line: 1,\r\n                    first_column: 0,\r\n                    last_line: 1,\r\n                    last_column: 0\r\n                };\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [0, 0];\r\n                }\r\n                this.offset = 0;\r\n                return this;\r\n            },\r\n            // consumes and returns one char from the input\r\n            input: function () {\r\n                var ch = this._input[0];\r\n                this.yytext += ch;\r\n                this.yyleng++;\r\n                this.offset++;\r\n                this.match += ch;\r\n                this.matched += ch;\r\n                var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\r\n                if (lines) {\r\n                    this.yylineno++;\r\n                    this.yylloc.last_line++;\r\n                }\r\n                else {\r\n                    this.yylloc.last_column++;\r\n                }\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range[1]++;\r\n                }\r\n                this._input = this._input.slice(1);\r\n                return ch;\r\n            },\r\n            // unshifts one char (or a string) into the input\r\n            unput: function (ch) {\r\n                var len = ch.length;\r\n                var lines = ch.split(/(?:\\r\\n?|\\n)/g);\r\n                this._input = ch + this._input;\r\n                this.yytext = this.yytext.substr(0, this.yytext.length - len);\r\n                //this.yyleng -= len;\r\n                this.offset -= len;\r\n                var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\r\n                this.match = this.match.substr(0, this.match.length - 1);\r\n                this.matched = this.matched.substr(0, this.matched.length - 1);\r\n                if (lines.length - 1) {\r\n                    this.yylineno -= lines.length - 1;\r\n                }\r\n                var r = this.yylloc.range;\r\n                this.yylloc = {\r\n                    first_line: this.yylloc.first_line,\r\n                    last_line: this.yylineno + 1,\r\n                    first_column: this.yylloc.first_column,\r\n                    last_column: lines ?\r\n                        (lines.length === oldLines.length ? this.yylloc.first_column : 0)\r\n                            + oldLines[oldLines.length - lines.length].length - lines[0].length :\r\n                        this.yylloc.first_column - len\r\n                };\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];\r\n                }\r\n                this.yyleng = this.yytext.length;\r\n                return this;\r\n            },\r\n            // When called from action, caches matched text and appends it on next action\r\n            more: function () {\r\n                this._more = true;\r\n                return this;\r\n            },\r\n            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\r\n            reject: function () {\r\n                if (this.options.backtrack_lexer) {\r\n                    this._backtrack = true;\r\n                }\r\n                else {\r\n                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\r\n                        text: \"\",\r\n                        token: null,\r\n                        line: this.yylineno\r\n                    });\r\n                }\r\n                return this;\r\n            },\r\n            // retain first n characters of the match\r\n            less: function (n) {\r\n                this.unput(this.match.slice(n));\r\n            },\r\n            // displays already matched input, i.e. for error messages\r\n            pastInput: function () {\r\n                var past = this.matched.substr(0, this.matched.length - this.match.length);\r\n                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\\n/g, \"\");\r\n            },\r\n            // displays upcoming input, i.e. for error messages\r\n            upcomingInput: function () {\r\n                var next = this.match;\r\n                if (next.length < 20) {\r\n                    next += this._input.substr(0, 20 - next.length);\r\n                }\r\n                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\r\n            },\r\n            // displays the character position where the lexing error occurred, i.e. for error messages\r\n            showPosition: function () {\r\n                var pre = this.pastInput();\r\n                var c = new Array(pre.length + 1).join(\"-\");\r\n                return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\r\n            },\r\n            // test the lexed token: return FALSE when not a match, otherwise return token\r\n            test_match: function (match, indexed_rule) {\r\n                var token, lines, backup;\r\n                if (this.options.backtrack_lexer) {\r\n                    // save context\r\n                    backup = {\r\n                        yylineno: this.yylineno,\r\n                        yylloc: {\r\n                            first_line: this.yylloc.first_line,\r\n                            last_line: this.last_line,\r\n                            first_column: this.yylloc.first_column,\r\n                            last_column: this.yylloc.last_column\r\n                        },\r\n                        yytext: this.yytext,\r\n                        match: this.match,\r\n                        matches: this.matches,\r\n                        matched: this.matched,\r\n                        yyleng: this.yyleng,\r\n                        offset: this.offset,\r\n                        _more: this._more,\r\n                        _input: this._input,\r\n                        yy: this.yy,\r\n                        conditionStack: this.conditionStack.slice(0),\r\n                        done: this.done\r\n                    };\r\n                    if (this.options.ranges) {\r\n                        backup.yylloc.range = this.yylloc.range.slice(0);\r\n                    }\r\n                }\r\n                lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\r\n                if (lines) {\r\n                    this.yylineno += lines.length;\r\n                }\r\n                this.yylloc = {\r\n                    first_line: this.yylloc.last_line,\r\n                    last_line: this.yylineno + 1,\r\n                    first_column: this.yylloc.last_column,\r\n                    last_column: lines ?\r\n                        lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\r\n                        this.yylloc.last_column + match[0].length\r\n                };\r\n                this.yytext += match[0];\r\n                this.match += match[0];\r\n                this.matches = match;\r\n                this.yyleng = this.yytext.length;\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [this.offset, this.offset += this.yyleng];\r\n                }\r\n                this._more = false;\r\n                this._backtrack = false;\r\n                this._input = this._input.slice(match[0].length);\r\n                this.matched += match[0];\r\n                token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\r\n                if (this.done && this._input) {\r\n                    this.done = false;\r\n                }\r\n                if (token) {\r\n                    return token;\r\n                }\r\n                else if (this._backtrack) {\r\n                    // recover context\r\n                    for (var k in backup) {\r\n                        this[k] = backup[k];\r\n                    }\r\n                    return false; // rule action called reject() implying the next rule should be tested instead.\r\n                }\r\n                return false;\r\n            },\r\n            // return next match in input\r\n            next: function () {\r\n                if (this.done) {\r\n                    return this.EOF;\r\n                }\r\n                if (!this._input) {\r\n                    this.done = true;\r\n                }\r\n                var token, match, tempMatch, index;\r\n                if (!this._more) {\r\n                    this.yytext = '';\r\n                    this.match = '';\r\n                }\r\n                var rules = this._currentRules();\r\n                for (var i = 0; i < rules.length; i++) {\r\n                    tempMatch = this._input.match(this.rules[rules[i]]);\r\n                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\r\n                        match = tempMatch;\r\n                        index = i;\r\n                        if (this.options.backtrack_lexer) {\r\n                            token = this.test_match(tempMatch, rules[i]);\r\n                            if (token !== false) {\r\n                                return token;\r\n                            }\r\n                            else if (this._backtrack) {\r\n                                match = false;\r\n                                continue; // rule action called reject() implying a rule MISmatch.\r\n                            }\r\n                            else {\r\n                                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n                                return false;\r\n                            }\r\n                        }\r\n                        else if (!this.options.flex) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (match) {\r\n                    token = this.test_match(match, rules[index]);\r\n                    if (token !== false) {\r\n                        return token;\r\n                    }\r\n                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n                    return false;\r\n                }\r\n                if (this._input === \"\") {\r\n                    return this.EOF;\r\n                }\r\n                else {\r\n                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\r\n                        text: \"\",\r\n                        token: null,\r\n                        line: this.yylineno\r\n                    });\r\n                }\r\n            },\r\n            // return next match that has a token\r\n            lex: function lex() {\r\n                var r = this.next();\r\n                if (r) {\r\n                    return r;\r\n                }\r\n                else {\r\n                    return this.lex();\r\n                }\r\n            },\r\n            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\r\n            begin: function begin(condition) {\r\n                this.conditionStack.push(condition);\r\n            },\r\n            // pop the previously active lexer condition state off the condition stack\r\n            popState: function popState() {\r\n                var n = this.conditionStack.length - 1;\r\n                if (n > 0) {\r\n                    return this.conditionStack.pop();\r\n                }\r\n                else {\r\n                    return this.conditionStack[0];\r\n                }\r\n            },\r\n            // produce the lexer rule set which is active for the currently active lexer condition state\r\n            _currentRules: function _currentRules() {\r\n                if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\r\n                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\r\n                }\r\n                else {\r\n                    return this.conditions[\"INITIAL\"].rules;\r\n                }\r\n            },\r\n            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\r\n            topState: function topState(n) {\r\n                n = this.conditionStack.length - 1 - Math.abs(n || 0);\r\n                if (n >= 0) {\r\n                    return this.conditionStack[n];\r\n                }\r\n                else {\r\n                    return \"INITIAL\";\r\n                }\r\n            },\r\n            // alias for begin(condition)\r\n            pushState: function pushState(condition) {\r\n                this.begin(condition);\r\n            },\r\n            // return the number of states currently on the stack\r\n            stateStackSize: function stateStackSize() {\r\n                return this.conditionStack.length;\r\n            },\r\n            options: { \"case-insensitive\": true },\r\n            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\r\n                var YYSTATE = YY_START;\r\n                switch ($avoiding_name_collisions) {\r\n                    case 0:\r\n                        break;\r\n                    case 1:\r\n                        return 'menor';\r\n                        break;\r\n                    case 2:\r\n                        return 'mayor';\r\n                        break;\r\n                    case 3:\r\n                        return 12;\r\n                        break;\r\n                    case 4:\r\n                        return 11;\r\n                        break;\r\n                    case 5:\r\n                        return 'igual';\r\n                        break;\r\n                    case 6:\r\n                        return 8;\r\n                        break;\r\n                    case 7:\r\n                        return 29;\r\n                        break;\r\n                    case 8:\r\n                        return 30;\r\n                        break;\r\n                    case 9:\r\n                        return 21;\r\n                        break;\r\n                    case 10:\r\n                        return 'div';\r\n                        break;\r\n                    case 11:\r\n                        return 'noIgual';\r\n                        break;\r\n                    case 12:\r\n                        return 'mayorQue';\r\n                        break;\r\n                    case 13:\r\n                        return 'menorQue';\r\n                        break;\r\n                    case 14:\r\n                        return 'and';\r\n                        break;\r\n                    case 15:\r\n                        return 'or';\r\n                        break;\r\n                    case 16:\r\n                        return '@';\r\n                        break;\r\n                    case 17:\r\n                        return 20;\r\n                        break;\r\n                    case 18:\r\n                        return 19;\r\n                        break;\r\n                    case 19:\r\n                        return 'dobleDosPuntos';\r\n                        break;\r\n                    case 20:\r\n                        return 23;\r\n                        break;\r\n                    case 21:\r\n                        return 25;\r\n                        break;\r\n                    case 22:\r\n                        return 'parentesisA';\r\n                        break;\r\n                    case 23:\r\n                        return 'parentesisC';\r\n                        break;\r\n                    case 24:\r\n                        return 'ancestor';\r\n                        break;\r\n                    case 25:\r\n                        return 'ancestor-or-self';\r\n                        break;\r\n                    case 26:\r\n                        return 'attribute';\r\n                        break;\r\n                    case 27:\r\n                        return 'child';\r\n                        break;\r\n                    case 28:\r\n                        return 'descendant';\r\n                        break;\r\n                    case 29:\r\n                        return 'descendant-or-self';\r\n                        break;\r\n                    case 30:\r\n                        return 'following';\r\n                        break;\r\n                    case 31:\r\n                        return 'following-sibling';\r\n                        break;\r\n                    case 32:\r\n                        return \"namespace\";\r\n                        break;\r\n                    case 33:\r\n                        return 'parent';\r\n                        break;\r\n                    case 34:\r\n                        return 'preceding';\r\n                        break;\r\n                    case 35:\r\n                        return 'preceding-sibling';\r\n                        break;\r\n                    case 36:\r\n                        return 'self';\r\n                        break;\r\n                    case 37:\r\n                        return 'NODO';\r\n                        break;\r\n                    case 38:\r\n                        return 'LANG';\r\n                        break;\r\n                    case 39:\r\n                        return 'POSICION';\r\n                        break;\r\n                    case 40:\r\n                        return 'ULTIMO';\r\n                        break;\r\n                    case 41:\r\n                        return 'TEXTO';\r\n                        break;\r\n                    case 42:\r\n                        return 'CADENA';\r\n                        break;\r\n                    case 43:\r\n                        return 27;\r\n                        break;\r\n                    case 44:\r\n                        return 26;\r\n                        break;\r\n                    case 45:\r\n                        return 13;\r\n                        break;\r\n                    case 46:\r\n                        return 5;\r\n                        break;\r\n                    case 47:\r\n                        new ControlError(yy_.yytext, TipoSeleccion.ERROR_LEXICO, yy_.yylloc.first_line, yy_.yylloc.first_column, \"XpathDescendente\");\r\n                        break;\r\n                }\r\n            },\r\n            rules: [/^(?:[\\s]+)/i, /^(?:<)/i, /^(?:>)/i, /^(?:\\/\\/)/i, /^(?:\\/)/i, /^(?:=)/i, /^(?:\\|)/i, /^(?:\\+)/i, /^(?:-)/i, /^(?:\\*)/i, /^(?:div\\b)/i, /^(?:!=)/i, /^(?:>=)/i, /^(?:<=)/i, /^(?:and\\b)/i, /^(?:or\\b)/i, /^(?:@)/i, /^(?:\\.)/i, /^(?:\\.\\.)/i, /^(?:::)/i, /^(?:\\[)/i, /^(?:\\])/i, /^(?:\\()/i, /^(?:\\))/i, /^(?:ancestor\\b)/i, /^(?:ancestor-or-self\\b)/i, /^(?:attribute\\b)/i, /^(?:child\\b)/i, /^(?:descendant\\b)/i, /^(?:descendant-or-self\\b)/i, /^(?:following\\b)/i, /^(?:following-sibling\\b)/i, /^(?:namespace\\b)/i, /^(?:parent\\b)/i, /^(?:preceding\\b)/i, /^(?:preceding-sibling\\b)/i, /^(?:self\\b)/i, /^(?:node\\b)/i, /^(?:lang\\b)/i, /^(?:position\\b)/i, /^(?:last\\b)/i, /^(?:text\\b)/i, /^(?:'[^\\']*')/i, /^(?:[0-9]+(\\.[0-9]+)\\b)/i, /^(?:[0-9]+\\b)/i, /^(?:[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:$)/i, /^(?:.)/i],\r\n            conditions: { \"INITIAL\": { \"rules\": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47], \"inclusive\": true } }\r\n        });\r\n        return lexer;\r\n    })();\r\n    parser.lexer = lexer;\r\n    function Parser() {\r\n        this.yy = {};\r\n    }\r\n    Parser.prototype = parser;\r\n    parser.Parser = Parser;\r\n    return new Parser;\r\n})();\r\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\r\n    exports.parser = xpathD;\r\n    exports.Parser = xpathD.Parser;\r\n    exports.parse = function () { return xpathD.parse.apply(xpathD, arguments); };\r\n    exports.main = function commonjsMain(args) {\r\n        if (!args[1]) {\r\n            console.log('Usage: ' + args[0] + ' FILE');\r\n            process.exit(1);\r\n        }\r\n        var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\r\n        return exports.parser.parse(source);\r\n    };\r\n    if (typeof module !== 'undefined' && require.main === module) {\r\n        exports.main(process.argv.slice(1));\r\n    }\r\n}\r\n","import { BrowserModule } from '@angular/platform-browser';\r\nimport { NgModule } from '@angular/core';\r\nimport { ReactiveFormsModule, FormsModule } from '@angular/forms';\r\nimport { HttpClientModule } from \"@angular/common/http\";\r\n\r\nimport { AppRoutingModule } from './app-routing.module';\r\nimport { AppComponent } from './app.component';\r\nimport { EditorComponent } from './components/editor/editor.component';\r\nimport { MonacoEditorModule, MONACO_PATH } from '@materia-ui/ngx-monaco-editor';\r\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\r\nimport { ArbolAstComponent } from 'src/app/components/arbol-ast/arbol-ast.component';\nimport { TablaSimbolosComponent } from './components/tabla-simbolos/tabla-simbolos.component'\r\n\r\n@NgModule({\r\n  declarations: [\r\n    AppComponent,\r\n    EditorComponent,\r\n    ArbolAstComponent,\r\n    TablaSimbolosComponent,\r\n  ],\r\n  imports: [\r\n    BrowserModule,\r\n    AppRoutingModule,\r\n    ReactiveFormsModule,\r\n    FormsModule,\r\n    MonacoEditorModule,\r\n    BrowserAnimationsModule,\r\n    HttpClientModule\r\n  ],\r\n  providers: [\r\n    {\r\n      provide: MONACO_PATH,\r\n      useValue: 'https://unpkg.com/monaco-editor@0.19.3/min/vs'\r\n    }\r\n  ],\r\n  bootstrap: [AppComponent]\r\n})\r\nexport class AppModule { }\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TipoVal;\r\n(function (TipoVal) {\r\n    TipoVal[\"ENTERO\"] = \"ENTERO\";\r\n    TipoVal[\"ID\"] = \"ID\";\r\n    TipoVal[\"DECIMAL\"] = \"DECIMAL\";\r\n    TipoVal[\"CADENA\"] = \"CADENA\";\r\n    TipoVal[\"ARROBA\"] = \"ARROBA\";\r\n    TipoVal[\"PUNTO\"] = \"PUTNO\";\r\n    TipoVal[\"LANG\"] = \"LANG\";\r\n    TipoVal[\"TEXTO\"] = \"TEXTO\";\r\n    TipoVal[\"POSICION\"] = \"POSICION\";\r\n    TipoVal[\"NODO\"] = \"NODO\";\r\n    TipoVal[\"BOLEANO\"] = \"BOLEANO\";\r\n    TipoVal[\"LAST\"] = \"LAST\";\r\n})(TipoVal = exports.TipoVal || (exports.TipoVal = {}));\r\n","<div class=\"row justify-content-center tabla\">\r\n    <div class=\"col-md-8 tab\">\r\n        <ul class=\"nav nav-tabs justify-content-center\">\r\n            <li class=\"nav-item active\">\r\n                <a class=\"nav-link active\" data-toggle=\"tab\" href=\"#simbolos\">Tabla de Símbolos</a>\r\n            </li>\r\n        </ul>\r\n       \r\n        <div id=\"myTabContent\" class=\"tab-content\">\r\n            <div class=\"tab-pane fade in active show\" id=\"simbolos\">\r\n                <div class=\"col-md-12\">\r\n                    <br>\r\n                    <div style=\"width: auto; height: auto;\">\r\n                        <table class=\"table table-hover table-hover\">\r\n                            <thead>\r\n                                <tr>\r\n                                    <td>NOMBRE</td>\r\n                                    <td>TIPO_SIMBOLO</td>\r\n                                    <td>AMBITO</td>\r\n                                    <td>COLUMNA</td>\r\n                                    <td>FILA</td>\r\n                                    <td>VALOR</td>\r\n                                </tr>\r\n                            </thead>\r\n                            <tbody>\r\n                                <tr *ngFor=\"let fila of tablaSimbolos\">\r\n                                    <td>{{fila.nombre}}</td>\r\n                                    <td>{{fila.tipo}}</td>\r\n                                    <td>-{{fila.listaAmbito.join(\"-\")}}-</td>\r\n                                    <td>{{fila.columna}}</td>\r\n                                    <td>{{fila.fila}}</td>\r\n                                    <td>--{{fila.valor}}--</td>\r\n                                </tr>\r\n                            \r\n                            </tbody>\r\n                        </table>\r\n                    </div>\r\n\r\n                    <div style=\"width: auto; height: auto;\">\r\n                        <ul class=\"nav nav-tabs justify-content-center\">\r\n                            <li class=\"nav-item active\">\r\n                                <a class=\"nav-link active\" data-toggle=\"tab\" href=\"#simbolos\">Tabla de Símbolos</a>\r\n                            </li>\r\n                        </ul>\r\n                        <table class=\"table table-primary table-hover\">\r\n                            <thead>\r\n                                <tr>\r\n                                    <td>PRODUCCION</td>\r\n                                    <td>regla_semantica</td>\r\n                                 \r\n                                </tr>\r\n                            </thead>\r\n                            <tbody>\r\n                                <tr *ngFor=\"let fila of ReporteGramatica\">\r\n                                    <td>{{fila.produccion}}</td>\r\n                                    <td>{{fila.regla_semantica}}</td>\r\n                                </tr>\r\n                            \r\n                            </tbody>\r\n                        </table>\r\n                    </div>\r\n                    <br>\r\n                </div>\r\n            </div>\r\n            <div class=\"tab-pane fade\" id=\"errores\">\r\n                <div class=\"col-md-12\">\r\n                    <br>\r\n                    <div style=\"width: auto; height: auto;\">\r\n                        <table class=\"table table-danger table-hover\">\r\n                            <thead>\r\n                                <tr>\r\n                                    <td>hola</td>\r\n                                    <td>mundo</td>\r\n                                </tr>\r\n                            </thead>\r\n                            <tbody>\r\n                                <tr>\r\n                                    <td>1</td>\r\n                                    <td>2</td>\r\n                                </tr>\r\n                            </tbody>\r\n                        </table>\r\n                    </div>\r\n                    <br>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>","import { Component, Input, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-tabla-simbolos',\n  templateUrl: './tabla-simbolos.component.html',\n  styleUrls: ['./tabla-simbolos.component.css']\n})\nexport class TablaSimbolosComponent implements OnInit {\n\n  @Input() tablaSimbolos:any \n            error:any\n            ReporteGramatica:any\n\n  constructor() {\n\n\n      }\n\n  ngOnInit(): void {\n  }\n\n}\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass Fila {\r\n    constructor(nombre, tipo, listaAmbito, fila, columna, valor) {\r\n        this.nombre = nombre;\r\n        this.tipo = tipo;\r\n        this.listaAmbito = listaAmbito;\r\n        this.fila = fila;\r\n        this.columna = columna;\r\n        this.valor = valor;\r\n    }\r\n}\r\nexports.Fila = Fila;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst NodoReporteGramatica_1 = require(\"./NodoReporteGramatica\");\r\nclass ReporteGramatica {\r\n    constructor(produccion, regla_semantica) {\r\n        ReporteGramatica.Lista.push(new NodoReporteGramatica_1.NodoReporteGramatica(produccion, regla_semantica));\r\n    }\r\n}\r\nexports.ReporteGramatica = ReporteGramatica;\r\nReporteGramatica.Lista = [];\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Graficas;\r\n(function (Graficas) {\r\n    function formatId(numId) {\r\n        return \"nodo\" + numId.toString();\r\n    }\r\n    function defNodo(nodoId, etiqueta) {\r\n        return formatId(nodoId) + \"[label=\\\"\" + etiqueta + \"\\\"] \\n\";\r\n    }\r\n    Graficas.defNodo = defNodo;\r\n    function defEdge(id1, id2) {\r\n        return formatId(id1) + \" -> \" + formatId(id2) + \"\\n\";\r\n    }\r\n    Graficas.defEdge = defEdge;\r\n    function getElement(id, etiqueta, idPadre) {\r\n        let dotText = \"\";\r\n        dotText += defNodo(id, etiqueta);\r\n        dotText += defEdge(idPadre, id);\r\n        return dotText;\r\n    }\r\n    Graficas.getElement = getElement;\r\n})(Graficas = exports.Graficas || (exports.Graficas = {}));\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Graficas_1 = require(\"../Graficas/Graficas\");\r\nclass EtiquetaInicio {\r\n    constructor(listaAtributos, linea, columna, idSent) {\r\n        this.linea = linea;\r\n        this.columna = columna;\r\n        this.idSent = idSent;\r\n        listaAtributos.forEach(atributo => {\r\n            if (atributo.nombre == \"version\") {\r\n                this.version = atributo.valor;\r\n            }\r\n            else if (atributo.nombre == \"encoding\") {\r\n                this.encoding = atributo.valor;\r\n            }\r\n        });\r\n    }\r\n    getCstDotA(idPadre) {\r\n        let texto = \"\";\r\n        texto += Graficas_1.Graficas.getElement(this.idSent, \"TAG_CONFIGURACION\", idPadre);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 1, \"AbreTagConf\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 2, \"<?\", this.idSent + 1);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 3, \"version\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 4, this.version.split(\"\\\"\").join(\"\"), this.idSent + 3);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 5, \"encoding\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 6, this.encoding.split(\"\\\"\").join(\"\"), this.idSent + 5);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 7, \"CierreTagConf\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 8, \"?>\", this.idSent + 7);\r\n        return texto;\r\n    }\r\n}\r\nexports.EtiquetaInicio = EtiquetaInicio;\r\n","import { NgModule } from '@angular/core';\r\nimport { RouterModule, Routes } from '@angular/router';\r\nimport { EditorComponent } from \"./components/editor/editor.component\";\r\nimport { ArbolAstComponent } from 'src/app/components/arbol-ast/arbol-ast.component'\r\nimport { TablaSimbolosComponent } from 'src/app/components/tabla-simbolos/tabla-simbolos.component'\r\nimport { TablaErroresComponent } from 'src/app/components/tabla-errores/tabla-errores.component'\r\n\r\nconst routes: Routes = [\r\n  {\r\n    path: '',\r\n    component: EditorComponent,\r\n    children: [\r\n      {path: 'arbolAst', component: ArbolAstComponent},\r\n      {path: 'tablaDeSimbolos', component:TablaSimbolosComponent},\r\n      {path: 'tablaDeErrores', component: TablaErroresComponent},\r\n    ]\r\n  }\r\n];\r\n\r\n@NgModule({ \r\n  imports: [RouterModule.forRoot(routes)],\r\n  exports: [RouterModule]\r\n})\r\nexport class AppRoutingModule { }\r\n","import { enableProdMode } from '@angular/core';\r\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\r\n\r\nimport { AppModule } from './app/app.module';\r\nimport { environment } from './environments/environment';\r\n\r\nif (environment.production) {\r\n  enableProdMode();\r\n}\r\n\r\nplatformBrowserDynamic().bootstrapModule(AppModule)\r\n  .catch(err => console.error(err));\r\n","function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = function() { return []; };\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nmodule.exports = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = \"zn8P\";"],"sourceRoot":"webpack:///"}